<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CosmWasm book cn</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded affix "><li class="part-title">入门指南</li><li class="chapter-item expanded "><a href="setting-up-env.html"><strong aria-hidden="true">1.</strong> 设置环境</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> 使用wasmd快速入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wasmd-quick-start/testnet.html"><strong aria-hidden="true">2.1.</strong> 测试网设置</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start/preparing-account.html"><strong aria-hidden="true">2.2.</strong> 准备账户</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start/testned-interaction.html"><strong aria-hidden="true">2.3.</strong> 与测试网交互</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">智能合约</li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">3.</strong> 基础知识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/rust-project.html"><strong aria-hidden="true">3.1.</strong> 创建Rust项目</a></li><li class="chapter-item expanded "><a href="basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> 入口点</a></li><li class="chapter-item expanded "><a href="basics/building-contract.html"><strong aria-hidden="true">3.3.</strong> 构建合约</a></li><li class="chapter-item expanded "><a href="basics/query.html"><strong aria-hidden="true">3.4.</strong> 创建查询</a></li><li class="chapter-item expanded "><a href="basics/query-testing.html"><strong aria-hidden="true">3.5.</strong> 测试查询</a></li><li class="chapter-item expanded "><a href="basics/multitest-intro.html"><strong aria-hidden="true">3.6.</strong> 介绍multitest</a></li><li class="chapter-item expanded "><a href="basics/state.html"><strong aria-hidden="true">3.7.</strong> 合约状态</a></li><li class="chapter-item expanded "><a href="basics/execute.html"><strong aria-hidden="true">3.8.</strong> 执行消息</a></li><li class="chapter-item expanded "><a href="basics/events.html"><strong aria-hidden="true">3.9.</strong> 事件、属性和数据</a></li><li class="chapter-item expanded "><a href="basics/funds.html"><strong aria-hidden="true">3.10.</strong> 处理资金</a></li><li class="chapter-item expanded "><a href="basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> 良好的实践</a></li><li class="chapter-item expanded "><a href="basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> 浮点类型</a></li></ol></li><li class="chapter-item expanded "><a href="actor-model.html"><strong aria-hidden="true">4.</strong> Actor模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="actor-model/idea.html"><strong aria-hidden="true">4.1.</strong> 概念</a></li><li class="chapter-item expanded "><a href="actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> 区块链中的Actor</a></li><li class="chapter-item expanded "><a href="actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> 合约作为Actor</a></li></ol></li><li class="chapter-item expanded "><a href="cross-contract.html"><strong aria-hidden="true">5.</strong> 跨合约通信</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cross-contract/design.html"><strong aria-hidden="true">5.1.</strong> 设计</a></li><li class="chapter-item expanded "><a href="cross-contract/fixing-admin.html"><strong aria-hidden="true">5.2.</strong> 修复管理员合约</a></li><li class="chapter-item expanded "><a href="cross-contract/map-storage.html"><strong aria-hidden="true">5.3.</strong> 映射存储</a></li><li class="chapter-item expanded "><a href="cross-contract/working-with-time.html"><strong aria-hidden="true">5.4.</strong> 处理时间</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 区块链间通信</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="impressum.html">法律信息</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CosmWasm book cn</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>本书是创建CosmWasm智能合约的指南。它将逐步引导您，并从简单到复杂的话题进行解释。</p>
<p>本书的目标不仅是告诉您有关智能合约API的知识，还要展示如何以清晰和可维护的方式进行开发。我们将向您展示CosmWasm创作者建立并鼓励您使用的设计模式。</p>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>本书探讨的是CosmWasm智能合约。本书不是Rust教程，假定读者具备基本的Rust知识。由于您可能会在阅读本书的同时学习Rust，我强烈建议您首先掌握Rust语言本身。您可以在<a href="https://www.rust-lang.org/learn">Rust学习</a>页面找到很好的入门资源。</p>
<h2 id="cosmwasm-api-文档"><a class="header" href="#cosmwasm-api-文档">CosmWasm API 文档</a></h2>
<p>本书是一种类似指南的文档。如果您正在寻找API文档，您可能会对以下文档感兴趣：</p>
<ul>
<li><a href="https://crates.io/crates/cosmwasm-std">cosmwasm-std</a></li>
<li><a href="https://crates.io/crates/cw-storage-plus">cw-storage-plus</a></li>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a></li>
<li><a href="https://crates.io/crates/cw-utils">cw-utils</a></li>
<li><a href="https://crates.io/crates/sylvia">sylvia framework</a></li>
</ul>
<h2 id="对本书做出贡献"><a class="header" href="#对本书做出贡献">对本书做出贡献</a></h2>
<p>本书在<a href="https://github.com/CosmWasm/book">Github</a>上进行维护，并从那里自动部署。如果您发现任何错误、漏洞或模糊之处，请创建<a href="https://github.com/CosmWasm/book/issues">issue</a>或提交pull request。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置环境"><a class="header" href="#设置环境">设置环境</a></h1>
<p>要使用 CosmWasm 智能合约，你需要在你的机器上安装 rust。如果你还没有，你可以在<a href="https://www.rust-lang.org/tools/install"> Rust 网站</a>上找到安装说明。</p>
<p>我假设你在这本书中使用的是稳定的 Rust 渠道。</p>
<p>此外，你需要安装 Wasm rust 编译器后端来构建 Wasm 二进制文件。安装它，请运行：</p>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<p>如果你想在测试网上试用你的合约，你将需要一个 <a href="https://github.com/CosmWasm/wasmd">wasmd</a> 二进制文件。我们将专注于使用 Rust 单元测试工具测试合约，所以不需要跟随。然而，看到产品在真实环境中工作可能很好。</p>
<p>要安装 <code>wasmd</code>，首先安装 <a href="https://github.com/golang/go/wiki#working-with-go">golang</a>。然后克隆 <code>wasmd</code> 并安装它：</p>
<pre><code>$ git clone git@github.com:CosmWasm/wasmd.git
$ cd ./wasmd
$ make install
</code></pre>
<p>此外，为了能够将 Rust Wasm 合约上传到区块链，你需要安装 <a href="https://www.docker.com/">docker</a>。为了最小化你的合约大小，你需要运行 CosmWasm Rust Optimizer；没有它，更复杂的合约可能会超过大小限制。</p>
<h2 id="cosmwasm-check-工具"><a class="header" href="#cosmwasm-check-工具">cosmwasm-check 工具</a></h2>
<p>构建智能合约的另一个有用工具是 <code>cosmwasm-check</code><a href="https://github.com/CosmWasm/cosmwasm/tree/main/packages/check">工具</a>。它允许你检查 wasm 二进制文件是否是一个准备好上传到区块链的合适的智能合约。你可以使用 cargo 安装它：</p>
<pre><code>$ cargo install cosmwasm-check
</code></pre>
<p>如果安装成功，你应该能够从命令行执行该工具。</p>
<pre><code>$ cosmwasm-check --version
Contract checking 1.2.3
</code></pre>
<h2 id="验证安装"><a class="header" href="#验证安装">验证安装</a></h2>
<p>为了确保你准备好构建你的智能合约，你需要确保你能够构建示例。查看 <a href="https://github.com/CosmWasm/cw-plus">cw-plus</a> 仓库，并在其文件夹中运行测试命令：</p>
<pre><code>$ git clone git@github.com:CosmWasm/cw-plus.git
$ cd ./cw-plus
cw-plus $ cargo test
</code></pre>
<p>你应该看到仓库中的所有内容都被编译，所有的测试都通过了。</p>
<p><code>cw-plus</code> 是找到示例合约的好地方 - 在 <code>contracts</code> 目录中查找它们。该仓库由 CosmWasm 创建者维护，所以其中的合约应该遵循良好的实践。</p>
<p>要验证 <code>cosmwasm-check</code> 工具，首先，你需要构建一个智能合约。进入某个合约目录，例如 <code>contracts/cw1-whitelist</code>，并调用 <code>cargo wasm</code>：</p>
<pre><code>cw-plus $ cd contracts/cw1-whitelist
cw-plus/contracts/cw1-whitelist $ cargo wasm
</code></pre>
<p>你应该能够在根仓库目录的 <code>target/wasm32-unknown-unknown/release/</code> 中找到你的输出二进制文件 - 不在合约目录本身！现在你可以检查合约验证是否通过：</p>
<pre><code>cw-plus/contracts/cw1-whitelist $ cosmwasm-check ../../target/wasm32-unknown-unknown/release/cw1_whitelist.wasm
Available capabilities: {&quot;iterator&quot;, &quot;cosmwasm_1_1&quot;, &quot;cosmwasm_1_2&quot;, &quot;stargate&quot;, &quot;staking&quot;}

../../target/wasm32-unknown-unknown/release/cw1_whitelist.wasm: pass

All contracts (1) passed checks!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用wasmd快速入门"><a class="header" href="#使用wasmd快速入门">使用<code>wasmd</code>快速入门</a></h1>
<p>本节是一个快速指南，介绍如何使用<code>wasmd</code>在实际区块链上测试您的智能合约。请注意，整个本节完全可选-如果您想开发合约并在UT环境中进行测试，可以跳过本节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试网络设置"><a class="header" href="#测试网络设置">测试网络设置</a></h1>
<p>要与区块链测试网络交互，首先要做的是选择一个测试网络。我建议使用我们通用的CosmWasm测试网络malaga-420。由于<code>wasmd</code>是通过环境变量进行配置的，我们将开始创建一个<code>malaga.env</code>文件，并将其设置为正确的值：</p>
<pre><code class="language-sh">export CHAIN_ID=&quot;malaga-420&quot;
export TESTNET_NAME=&quot;malaga-420&quot;
export FEE_DENOM=&quot;umlg&quot;
export STAKE_DENOM=&quot;uand&quot;
export BECH32_HRP=&quot;wasm&quot;
export WASMD_VERSION=&quot;v0.27.0&quot;
export CONFIG_DIR=&quot;.wasmd&quot;
export BINARY=&quot;wasmd&quot;

export GENESIS_URL=&quot;https://raw.githubusercontent.com/CosmWasm/testnets/master/malaga-420/config/genesis.json&quot;

export RPC=&quot;https://rpc.malaga-420.cosmwasm.com:443&quot;
export FAUCET=&quot;https://faucet.malaga-420.cosmwasm.com&quot;

export COSMOVISOR_VERSION=&quot;v0.42.10&quot;
export COSMOVISOR_HOME=/root/.wasmd
export COSMOVISOR_NAME=wasmd

export NODE=(--node $RPC)
export TXFLAG=($NODE --chain-id $CHAIN_ID --gas-prices 0.05umlg --gas auto --gas-adjustment 1.3)
</code></pre>
<p>如果您是Fish用户，这个<code>malaga.fish</code>文件可能更适合您：</p>
<pre><code class="language-fish">set -x CHAIN_ID malaga-420
set -x TESTNET_NAME malaga-420
set -x FEE_DENOM umlg
set -x STAKE_DENOM uand
set -x BECH32_HRP wasm
set -x WASMD_VERSION v0.27.0
set -x CONFIG_DIR .wasmd
set -x BINARY wasmd

set -x GENESIS_URL https://raw.githubusercontent.com/CosmWasm/testnets/master/malaga-420/config/genesis.json

set -x RPC https://rpc.malaga-420.cosmwasm.com:443
set -x FAUCET https://faucet.malaga-420.cosmwasm.com

set -x COSMOVISOR_VERSION v0.42.10
set -x COSMOVISOR_HOME /root/.wasmd
set -x COSMOVISOR_NAME wasmd

set -x NODE $RPC
set -x TXFLAG --node $RPC --chain-id $CHAIN_ID --gas-prices 0.05umlg --gas-adjustment 1.3 --gas auto -b block
</code></pre>
<p>Now source the file to our environment (for fish use <code>malaga.fish</code> in place of <code>malaga.env</code>):</p>
<pre><code class="language-sh">$ source ./malaga.env
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备账户"><a class="header" href="#准备账户">准备账户</a></h1>
<p>与测试网络进行交互的第一件事是拥有一个有效的账户。首先，在<code>wasmd</code>配置中添加一个新的密钥：</p>
<pre><code>$ wasmd keys add wallet
- name: wallet
  type: local
  address: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;A8pamTZH8x8+8UAFjndrvU4x7foJbCvcz78buyQ8q7+k&quot;}'
  mnemonic: &quot;&quot;
...
</code></pre>
<p>通过这个命令，您可以获得关于准备好的账户的信息。这里有两个相关的内容：</p>
<ul>
<li>地址是您在区块链中的身份</li>
<li>助记词（在示例中由我省略）是由12个单词组成的，允许您重新创建一个账户，以便您可以在不同的设备上使用它</li>
</ul>
<p>出于测试目的，存储助记词可能从来不是必要的，但在现实世界中，这是需要保持安全的关键信息。</p>
<p>现在，当您创建一个账户时，您需要用一些代币初始化它-您将需要这些代币来支付与区块链的任何交互-我们称之为操作的“燃料成本”。通常情况下，您需要以某种方式购买这些代币，但在测试网络中，您通常可以在您的账户上创建任意数量的代币。在malaga网络上，可以执行以下操作：</p>
<pre><code>$ curl -X POST --header &quot;Content-Type: application/json&quot; \
  --data '{ &quot;denom&quot;: &quot;umlg&quot;, &quot;address&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot; }' \
  https://faucet.malaga-420.cosmwasm.com/credit
</code></pre>
<p>这是一个简单的HTTP POST请求，目标是<code>https://faucet.malaga-420.cosmwasm.com/credit</code>端点。该请求的数据是一个JSON，包含要铸造的代币名称和应该接收新代币的地址。在这里，我们铸造的是<code>umlg</code>代币，这是在malaga测试网络中用于支付燃料费用的代币。</p>
<p>您现在可以通过调用以下命令（用您自己的地址替换我的地址）来验证您的账户代币余额：</p>
<pre><code>$ wasmd query bank balances wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
balances:
- amount: &quot;100000000&quot;
  denom: umlg
pagination:
  next_key: null
  total: &quot;0&quot;
</code></pre>
<p>拥有100M个代币应该足够供您玩耍了，如果您需要更多，您可以随时铸造另一批代币。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与测试网络交互"><a class="header" href="#与测试网络交互">与测试网络交互</a></h1>
<p>区块链交互是通过<a href="https://github.com/CosmWasm/wasmd">wasmd</a>命令行工具来执行的。要开始使用测试网络，我们需要上传一些智能合约代码。现在，我们将使用<code>cw-plus</code>存储库中的示例<code>cw4-group</code>。首先克隆该存储库：</p>
<pre><code>$ git clone git@github.com:CosmWasm/cw-plus.git
</code></pre>
<p>现在转到克隆的存储库并对其运行Rust优化器：</p>
<pre><code>$ docker run --rm -v &quot;$(pwd)&quot;:/code \
  --mount type=volume,source=&quot;$(basename &quot;$(pwd)&quot;)_cache&quot;,target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.6
</code></pre>
<p>几分钟后（第一次可能需要一些时间），您的存储库中应该有一个<code>artifact</code>目录，其中应该有一个<code>cw4-group.wasm</code>文件，这是我们要上传的合约。要执行此操作，请运行以下命令-请注意，<code>wallet</code>是您在前面章节中创建的密钥的名称：</p>
<pre><code>$ wasmd tx wasm store ./artifacts/cw4_group.wasm --from wallet $TXFLAG -y -b block

...
logs:
- events:
  - attributes:
    - key: action
      value: /cosmwasm.wasm.v1.MsgStoreCode
    - key: module
      value: wasm
    - key: sender
      value: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    type: message
  - attributes:
    - key: code_id
      value: &quot;12&quot;
    type: store_code
...
</code></pre>
<p>执行完毕后，您应该会得到一个非常长的输出，其中包含有关发生的情况的信息。其中大部分是一个古老的密码（也称为base64）和执行元数据，但我们要寻找的是<code>logs</code>部分。应该会有一个名为<code>store_code</code>的事件，其中只有一个属性<code>code_id</code>-其<code>value</code>字段是我们上传的合约的代码ID-在我的情况下是12。</p>
<p>现在，当我们上传了代码之后，我们可以继续实例化一个合约来创建它的新实例：</p>
<pre><code>$ wasmd tx wasm instantiate 12 \
  '{ &quot;admin&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot;, &quot;members&quot;: [] }' \
  --from wallet --label &quot;Group&quot; --no-admin $TXFLAG -y

...
logs:
- events:
  - attributes:
    - key: _contract_address
      value: wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz
    - key: code_id
      value: &quot;12&quot;
    type: instantiate
  - attributes:
    - key: action
      value: /cosmwasm.wasm.v1.MsgInstantiateContract
    - key: module
      value: wasm
    - key: sender
      value: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    type: message
...

</code></pre>
<p>在这个命令中，<code>12</code>是代码ID-上传代码的结果。之后，一个JSON是一个实例化消息-稍后我会详细讨论这个。只需将其视为一个需要字段来创建新合约的消息。每个合约都有其实例化消息格式。对于<code>cw4-group</code>，有两个字段：<code>admin</code>是一个地址，该地址有资格在该合约上执行消息。将其设置为您的地址非常重要，因为我们将希望学习如何执行合约。<code>members</code>是一个地址数组，是组的初始成员。我们现在将其保留为空，但您可以在其中放入任何地址。在这里，我在命令行中内联放入了有关消息的提示，但我经常将要发送的消息放入文件中，并通过<code>$(cat msg.json)</code>进行嵌入。这是fish语法，但是每个shell都提供了这样的语法。</p>
<p>然后，在消息之后，您需要添加几个附加标志。<code>--from wallet</code>与之前的相同-之前创建的密钥的名称。<code>--label &quot;Group&quot;</code>只是您的合约的任意名称。一个重要的标志是<code>--no-admin</code>标志-请记住，这是我们在实例化消息中设置的不同的&quot;admin&quot;。此标志仅与合约迁移相关，但我们现在不涉及它们，所以将此标志保持不变。</p>
<p>现在，看一下执行的结果。它与之前非常相似-有关执行过程的许多数据。同样，我们需要仔细查看响应的<code>logs</code>部分。这次我们正在查看一个类型为<code>instantiate</code>的事件，以及<code>_contract_address</code>属性-其值是新创建的合约地址-例如<code>wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux</code>。</p>
<p>现在让我们继续查询我们的合约：</p>
<pre><code>$ wasmd query wasm contract-state smart \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;list_members&quot;: {} }'

data:
  members: []
</code></pre>
<p>请记得将地址（紧接着<code>smart</code>后面的地址）更改为您的合约地址。之后，还有另一条消息-这次是查询消息-发送到合约中。该查询应该返回一个成员列表。实际上，它确实返回了一个单独的<code>data</code>对象，其中包含一个字段-空的成员列表。这很简单，现在让我们尝试最后一件事情：执行操作：</p>
<pre><code>$ wasmd tx wasm execute \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;update_members&quot;: { &quot;add&quot;: [{ &quot;addr&quot;: &quot;wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux&quot;, &quot;weight&quot;: 1 }], &quot;remove&quot;: [] } }' \
  --from wallet $TXFLAG
</code></pre>
<p>正如您所看到的，执行操作与实例化非常相似。区别在于，实例化只调用一次，而执行需要一个合约地址。可以说实例化是第一次执行的特殊情况，它返回合约地址。与之前一样，我们可以看到我们得到了一些日志输出-您可以分析它以查看可能发生了什么。但要确保在区块链上有影响，最好的方法是再次查询它：</p>
<pre><code>$ wasmd query wasm contract-state smart \
  wasm18yn206ypuxay79gjqv6msvd9t2y49w4fz8q7fyenx5aggj0ua37q3h7kwz \
  '{ &quot;list_members&quot;: {} }'

data:
  members:
  - addr: wasm1wukxp2kldxae36rgjz28umqtq792twtxdfe6ux
    weight: 1
</code></pre>
<p>目前，这就是您需要了解的关于<code>wasmd</code>基础知识的全部内容，以便能够与您的简单合约进行交互。我们将重点关注在本地测试它们，但如果您想在真实环境中进行检查，您现在已经掌握了一些基本知识。稍后，当我们讨论定义智能合约之间通信的actor模型的架构时，我们将更详细地了解<code>wasmd</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h1>
<p>在本章中，我们将逐步介绍创建基本智能合约的过程。
我将尝试解释CosmWasm背后的核心思想和典型的合约结构。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-rust-project"><a class="header" href="#create-a-rust-project">Create a Rust project</a></h1>
<p>As smart contracts are Rust library crates, we will start with creating one:</p>
<pre><code>$ cargo new --lib ./empty-contract
</code></pre>
<p>You created a simple Rust library, but it is not yet ready to be a smart contract. The first thing
to do is to update the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }

</code></pre>
<p>As you can see, I added a <code>crate-type</code> field for the library section. Generating the <code>cdylib</code> is
required to create a proper web assembly binary. The downside of this is that such a library cannot
be used as a dependency for other Rust crates - for now, it is not needed, but later we will show
how to approach reusing contracts as dependencies.</p>
<p>Additionally, there is one core dependency for smart contracts: the <code>cosmwasm-std</code>. This crate is a
standard library for smart contracts. It provides essential utilities for communication with the
outside world and a couple of helper functions and types. Every smart contract we will build will
use this dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入口点"><a class="header" href="#入口点">入口点</a></h1>
<p>典型的 Rust 应用程序从操作系统调用的 <code>fn main()</code> 函数开始。智能合约并无显著不同。当消息发送到合约时，一个被称为&quot;入口点&quot;的函数被调用。与只有一个 <code>main</code> 入口点的原生应用程序不同，智能合约有一些对应于不同消息类型的入口点：<code>instantiate</code>，<code>execute</code>，<code>query</code>，<code>sudo</code>，<code>migrate</code> 等等。</p>
<p>首先，我们将从三个基本入口点开始：</p>
<ul>
<li><code>instantiate</code> 在智能合约的生命周期中只被调用一次 - 你可以将其视为合约的构造器或初始化器。</li>
<li><code>execute</code> 用于处理能够修改合约状态的消息 - 它们被用来执行一些实际的操作。</li>
<li><code>query</code> 用于处理请求从合约获取一些信息的消息；与 <code>execute</code> 不同，它们永远不会影响任何合约状态，只是像数据库查询一样被使用。</li>
</ul>
<p>转到你的 <code>src/lib.rs</code> 文件，并从 <code>instantiate</code> 入口点开始：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

#[entry_point]
pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}</code></pre>
<p>事实上，<code>instantiate</code> 是智能合约有效所必需的唯一入口点。虽然这种形式不是很有用，但它是一个开始。让我们仔细看看入口点的结构。</p>
<p>首先，我们开始导入一些类型以便更一致地使用。然后我们定义我们的入口点。<code>instantiate</code> 接受四个参数：</p>
<ul>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.DepsMut.html"><code>deps: DepsMut</code></a>
是一个与外部世界通信的实用类型 - 它允许查询和更新合约状态，查询其他合约状态，并提供访问 <code>Api</code> 对象的途径，该对象有一些用于处理 CW 地址的辅助函数。</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Env.html"><code>env: Env</code></a>
是一个代表执行消息时的区块链状态的对象 - 链高度和id，当前时间戳，和被调用的合约地址。</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.MessageInfo.html"><code>info: MessageInfo</code></a>
包含触发执行的消息的元信息 - 发送消息的地址，和随消息发送的链原生代币。</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Empty.html"><code>msg: Empty</code></a>
是触发执行的消息本身 - 现在，它是代表 <code>{}</code> JSON 的 <code>Empty</code> 类型，但是这个参数的类型可以是任何可反序列化的类型，我们将来会在这里传递更复杂的类型。</li>
</ul>
<p>如果你对区块链还不熟悉，那么这些参数可能对你来说没有太多意义，但是在学习这个指南的过程中，我将逐一解释它们的用途。</p>
<p>注意装饰我们入口点的重要属性 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/attr.entry_point.html"><code>#[entry_point]</code></a>。它的目的是将整个入口点包装成 Wasm 运行时可以理解的形式。适当的 Wasm 入口点只能使用 Wasm 规范原生支持的基本类型，Rust 结构和枚举不在此列。使用这样的入口点会相当复杂，所以 CosmWasm 的创作者提供了 <code>entry_point</code> 宏。它创建了原始的 Wasm 入口点，内部调用装饰函数，并做所有必要的魔法以从 Wasm 运行时传递的参数构建我们的高级 Rust 参数。</p>
<p>下一个要看的是返回类型。我用 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/type.StdResult.html"><code>StdResult&lt;Response&gt;</code></a> 作为这个简单例子的返回类型，它是 <code>Result&lt;Response, StdError&gt;</code> 的别名。返回入口点类型总会是一个 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> 类型，有一些实现 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait 的错误类型和一个明确定义的成功情况类型。对于大多数入口点，&quot;Ok&quot; 情况将是 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html"><code>Response</code></a> 类型，它允许将合约适配到我们的 actor 模型，我们将很快讨论这个模型。</p>
<p>入口点的主体尽可能简单 - 它总是成功返回一个简单的空响应。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建合约"><a class="header" href="#构建合约">构建合约</a></h1>
<p>现在是构建我们的合约的时候了。我们可以使用传统的 cargo 构建管道进行本地测试：<code>cargo build</code> 用于编译它，<code>cargo test</code> 用于运行所有测试（我们还没有，但我们很快就会进行）。</p>
<p>然而，我们需要创建一个 wasm 二进制文件以将合约上传到区块链。我们可以通过向构建命令传递额外的参数来实现这一点：</p>
<pre><code>$ cargo build --target wasm32-unknown-unknown --release
</code></pre>
<p><code>--target</code> 参数告诉 cargo 为给定目标执行交叉编译，而不是为运行它的操作系统构建原生二进制文件 - 在这种情况下，<code>wasm32-unknown-unknown</code>，这是 Wasm 目标的奇特名称。</p>
<p>另外，我将 <code>--release</code> 参数传递给了命令 - 这并不是必需的，但在大多数情况下，链上运行时调试信息并不是很有用。减小上传的二进制文件大小对于最小化 gas 成本是至关重要的。值得知道的是，有一个 <a href="https://github.com/CosmWasm/rust-optimizer">CosmWasm Rust 优化器</a> 工具，负责构建更小的二进制文件。对于生产环境，所有的合约都应该使用这个工具进行编译，但是对于学习目的，这并不是必须做的。</p>
<h2 id="别名构建命令"><a class="header" href="#别名构建命令">别名构建命令</a></h2>
<p>现在我可以看出你对使用一些过于复杂的命令构建你的合约感到失望，而不是简单的 <code>cargo build</code>。希望这不是事实。常见的做法是为构建命令设置别名，使其像构建原生应用一样简单。</p>
<p>让我们在你的合约项目目录中创建 <code>.cargo/config</code> 文件，内容如下：</p>
<pre><code class="language-toml">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown&quot;
</code></pre>
<p>现在，构建你的 Wasm 二进制文件就像执行 <code>cargo wasm</code> 一样简单。我们还添加了额外的 <code>wasm-debug</code> 命令，用于我们想要构建包含调试信息的 wasm 二进制文件的罕见情况。</p>
<h2 id="检查合约有效性"><a class="header" href="#检查合约有效性">检查合约有效性</a></h2>
<p>当合约被构建时，最后一步是确保它是有效的 CosmWasm 合约，方法是对其调用 <code>cosmwasm-check</code>：</p>
<pre><code>$ cargo wasm
...
$ cosmwasm-check ./target/wasm32-unknown-unknown/release/contract.wasm
Available capabilities: {&quot;cosmwasm_1_1&quot;, &quot;staking&quot;, &quot;stargate&quot;, &quot;iterator&quot;, &quot;cosmwasm_1_2&quot;}

./target/wasm32-unknown-unknown/release/contract.wasm: pass
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建查询"><a class="header" href="#创建查询">创建查询</a></h1>
<p>我们已经创建了一个简单的合约，对空的实例化消息作出了反应。不幸的是，它并不是很有用。让我们稍微增加一些响应性。</p>
<p>首先，我们需要将 <a href="https://crates.io/crates/serde"><code>serde</code></a> 库添加到我们的依赖项中。它将帮助我们进行查询消息的序列化和反序列化。更新 <code>Cargo.toml</code> 文件：</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>现在进入你的 <code>src/lib.rs</code> 文件，添加一个新的查询入口点：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo,
    Response, StdResult,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct QueryResp {
    message: String,
}

<span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, _msg: Empty) -&gt; StdResult&lt;Binary&gt; {
    let resp = QueryResp {
        message: &quot;Hello World&quot;.to_owned(),
    };

    to_binary(&amp;resp)
}</code></pre>
<p>请注意，为了简单起见，我省略了之前创建的实例化入口点 - 为了不给你过多的代码负担，我只会显示代码中发生变化的部分。</p>
<p>首先，我们需要一个结构体来作为查询的返回结果。我们希望始终返回可序列化的内容。我们只需使用 <code>serde</code> 库来派生 <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> 和 <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a> traits。</p>
<p>然后，我们需要实现查询入口点。它与 <code>instantiate</code> 的入口点非常相似。第一个显著的区别是 <code>deps</code> 参数的类型。对于 <code>instantiate</code>，它是 <code>DepMut</code> 类型，但在这里我们使用了 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Deps.html"><code>Deps</code></a> 对象。这是因为查询不能改变智能合约的内部状态，它只能读取状态。这带来了一些后果 - 例如，无法为将来的查询实现缓存（因为它需要某种数据缓存来写入）。</p>
<p>另一个区别是缺少 <code>info</code> 参数。这是因为执行操作的入口点（</p>
<p>例如实例化或执行）可以根据消息元数据的不同方式执行操作 - 例如，它们可以限制谁可以执行操作（通过检查消息的发送者）。而对于查询则不同。查询仅仅是纯粹地返回一些经过转换的合约状态。它可以基于一些链上元数据计算状态（因此状态可以在一段时间后&quot;自动&quot;更改），但不能基于消息信息进行计算。</p>
<p>请注意，我们的入口点仍然使用相同的 <code>Empty</code> 类型作为 <code>msg</code> 参数 - 这意味着我们发送给合约的查询消息仍然是一个空的 JSON 对象：<code>{}</code></p>
<p>最后一个发生变化的地方是返回类型。与其返回成功时的 <code>Response</code> 类型，我们返回一个任意可序列化的对象。这是因为查询不使用典型的 Actor 模型消息流 - 它们无法触发任何操作，也无法以不同于查询的方式与其他合约进行通信（这由 <code>deps</code> 参数处理）。查询始终返回纯粹的数据，应该直接呈现给查询器。</p>
<p>现在看一下实现。其中没有复杂的操作 - 我们创建了要返回的对象，并使用 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/fn.to_binary.html"><code>to_binary</code></a> 函数将其编码为 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Binary.html"><code>Binary</code></a> 类型。</p>
<h2 id="改进消息"><a class="header" href="#改进消息">改进消息</a></h2>
<p>我们有一个查询，但查询消息存在一个问题。它总是一个空的 JSON。这非常糟糕 - 如果我们将来想要添加另一个查询，很难在查询变体之间进行合理的区分。</p>
<p>在实践中，我们可以通过使用非空的查询消息类型来解决这个问题。改进我们的合约：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize)]
</span><span class="boring">struct QueryResp {
</span><span class="boring">    message: String,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
pub enum QueryMsg {
    Greet {},
}

<span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; {
            let resp = QueryResp {
                message: &quot;Hello World&quot;.to_owned(),
            };

            to_binary(&amp;resp)
        }
    }
}</code></pre>
<p>现在我们为查询消息引入了适当的消息类型。它是一个<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">枚举类型</a>，默认情况下，它将序列化为一个具有单个字段的 JSON - 字段的名称将是枚举变体的名称（在我们的例子中始终是&quot;greet&quot; - 目前至少是如此），而该字段的值将是分配给此枚举变体的对象。</p>
<p>请注意，我们的枚举没有为唯一的 <code>Greet</code> 变体分配类型。在 Rust 中，我们通常在变体名称后不添加额外的 <code>{}</code>。但是这里的花括号是有目的的 - 如果没有它们，变体将序列化为只有字符串类型 - 因此，该变体的 JSON 表示形式将为 <code>&quot;greet&quot;</code>，而不是 <code>{ &quot;greet&quot;: {} }</code>。这种行为导致了消息模式的不一致性。通常，为了更好地表示 JSON，我们总是为可序列化的空枚举变体添加 <code>{}</code>。</p>
<p>但是，我们还可以进一步改进代码。现在，<code>query</code> 函数有两个职责。第一个是显而易见的 - 处理查询本身。这是最初的假设，现在仍然存在。但是还有一个新的事情正在发生 - 查询消息的分发。尽管只有一个变体，但 <code>query</code> 函数很容易变成一个庞大而难以阅读的 <code>match</code> 语句。为了使代码更符合<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则，我们将进行重构，并将处理 <code>greet</code> 消息的部分提取到一个单独的函数中。</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
pub struct GreetResp {
    message: String,
}

<span class="boring">#[derive(Serialize, Deserialize)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
    }
}

mod query {
    use super::*;

    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
        let resp = GreetResp {
            message: &quot;Hello World&quot;.to_owned(),
        };

        Ok(resp)
    }
}</code></pre>
<p>现在看起来好多了。请注意，还有几个额外的改进。我将查询响应类型 <code>GreetResp</code> 的字段设为公共字段。因为它们现在需要从不同的模块中访问。然后，将我的新函数封装在名为 <code>query</code> 的模块中。这样可以更容易地避免名称冲突 - 将来我可以在查询和执行消息中具有相同的变体，它们的处理程序将位于不同的命名空间中。</p>
<p><code>greet</code> 函数返回 <code>StdResult</code> 而不是 <code>GreetResp</code>，这可能是一个值得质疑的决定，因为它永远不会返回错误。这是一个风格问题，但我更喜欢在消息处理程序中保持一致性，其中大部分处理程序可能会有失败的情况 - 例如读取状态时。</p>
<p>此外，你可以将 <code>deps</code> 和 <code>env</code> 参数传递给所有的查询处理程序以保持一致性。我对此不太喜欢，因为它引入了不必要的样板代码，不易读，但我也同意保持一致性的论点 - 我将这个决定留给你自己判断。</p>
<h2 id="结构化合约"><a class="header" href="#结构化合约">结构化合约</a></h2>
<p>你可以看到我们的合约现在变得稍微复杂了一些。大约 50 行可能不算太多，但在一个文件中有许多不同的实体，我认为我们可以做得更好。通常情况下，我们会将它们分为三个文件。从提取所有消息到 <code>src/msg.rs</code> 开始：</p>
<pre><code class="language-rust noplayground">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize)]
pub enum QueryMsg {
    Greet {},
}</code></pre>
<p>你可能已经注意到，我将 <code>GreetResp</code> 的字段设为公共字段。这是因为它们现在需要从不同的模块中访问。现在继续前进到 <code>src/contract.rs</code> 文件：</p>
<pre><code class="language-rust noplayground">use crate::msg::{GreetResp, QueryMsg};
use cosmwasm_std::{
    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}

pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
    }
}

mod query {
    use super::*;

    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
        let resp = GreetResp {
            message: &quot;Hello World&quot;.to_owned(),
        };

        Ok(resp)
    }
}</code></pre>
<p>我将大部分逻辑都移到了这里，所以我的 <code>src/lib.rs</code> 只是一个非常薄的库入口，除了模块定义和入口点定义之外没有其他内容。我从 <code>src/contract.rs</code> 的 <code>query</code> 函数中移除了 <code>#[entry_point]</code> 属性。我将函数的处理部分拆分出来，现在 <code>contract::query</code> 函数是负责分发查询消息的顶层查询处理程序。顶层的 <code>query</code> 函数只是一个入口点。这是一个微妙的区别，但在将来当我们不想生成入口点而保留分发函数时，它将变得有意义。我现在引入了这个拆分，以展示典型的合约结构。</p>
<p>现在是最后一部分，<code>src/lib.rs</code> 文件：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

mod contract;
mod msg;

#[entry_point]
pub fn instantiate(deps: DepsMut, env: Env, info: MessageInfo, msg: Empty)
  -&gt; StdResult&lt;Response&gt;
{
    contract::instantiate(deps, env, info, msg)
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg)
  -&gt; StdResult&lt;Binary&gt;
{
    contract::query(deps, env, msg)
}</code></pre>
<p>非常简单的顶层模块。定义子模块和入口点，没有其他内容。</p>
<p>现在，当我们准备好测试合约时，让我们继续。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试查询"><a class="header" href="#测试查询">测试查询</a></h1>
<p>上次我们创建了一个新的查询，现在是时候测试一下了。我们将从基础知识开始 - 单元测试。这种方法简单且不需要除了 Rust 之外的知识。转到 <code>src/contract.rs</code> 并在其模块中添加一个测试：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greet_query() {
        let resp = query::greet().unwrap();
        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}</code></pre>
<p>如果你以前在 Rust 中编写过单元测试，那么这里不应该有什么意外。只是一个简单的仅用于测试的模块，包含本地函数单元测试。问题是 - 此测试尚未构建。我们需要稍微调整一下消息类型。更新 <code>src/msg.rs</code>：</p>
<pre><code class="language-rust noplayground"><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum QueryMsg {
    Greet {},
}</code></pre>
<p>我为两种消息类型添加了三个新的衍生。<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> 是必需的，以允许比较类型是否相等 - 这样我们就可以检查它们是否相等了。<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> 是一种生成调试打印工具的 trait。它被 <a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a> 用于在断言失败时显示不匹配的信息。请注意，因为我们没有以任何方式测试 <code>QueryMsg</code>，额外的 trait 衍生是可选的。但是，为了测试性和一致性，将所有消息都设为 <code>PartialEq</code> 和 <code>Debug</code> 是一个好习惯。最后一个 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> 目前还不需要，但是 将消息克隆到其他地方也是一个好习惯。我们以后也会需要它，所以我已经添加了它，以免来回更改。</p>
<p>现在我们准备运行测试：</p>
<pre><code>$ cargo test

...
running 1 test
test contract::tests::greet_query ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>耶！测试通过了！</p>
<h2 id="合约作为黑盒"><a class="header" href="#合约作为黑盒">合约作为黑盒</a></h2>
<p>现在让我们再进一步。Rust 的测试工具是一个友好的工具，用于构建更高级别的测试。我们当前正在测试智能合约的内部，但是如果你考虑一下你的智能合约如何在外部世界中可见。它是一个由一些输入消息触发的单个实体。我们可以通过我们的 <code>query</code> 函数创建将整个合约视为黑盒的测试。让我们更新我们的测试：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use cosmwasm_std::from_binary;
    use cosmwasm_std::testing::{mock_dependencies, mock_env};

    use super::*;

    #[test]
    fn greet_query() {
        let resp = query(
            mock_dependencies().as_ref(),
            mock_env(),
            QueryMsg::Greet {}
        ).unwrap();
        let resp: GreetResp = from_binary(&amp;resp).unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}</code></pre>
<p>我们需要为 <code>query</code> 函数提供两个实体：<code>deps</code> 和 <code>env</code> 实例。幸运的是，<code>cosmwasm-std</code> 提供了用于测试这些实例的实用工具 - <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_dependencies.html"><code>mock_dependencies</code></a> 和 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_env.html"><code>mock_env</code></a> 函数。</p>
<p>你可能会注意到 <code>deps</code> 的依赖项模拟类型是 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html"><code>OwnedDeps</code></a> 而不是我们这里需要的 <code>Deps</code>，这就是为什么在它上面调用 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html#method.as_ref"><code>as_ref</code></a> 函数的原因。如果我们寻找的是 <code>DepsMut</code> 对象，我们将使用 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html#method.as_mut"><code>as_mut</code></a>。</p>
<p>我们可以重新运行测试，应该仍然通过。但是当我们考虑该测试是否反映了实际用例时，它是不准确的。合约被查询了，但是它还没有被实例化！在软件工程中，这相当于在没有构造对象的情况下调用 getter - 从无处获取它。这是一种糟糕的测试方法。我们可以做得更好：</p>
<pre><code class="language-rust noplayground">
<span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use cosmwasm_std::from_binary;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};

    use super::*;

    #[test]
    fn greet_query() {
        let mut deps = mock_dependencies();
        let env = mock_env();

        instantiate(
            deps.as_mut(),
            env.clone(),
            mock_info(&quot;sender&quot;, &amp;[]),
            Empty {},
        )
        .unwrap();

        let resp = query(deps.as_ref(), env, QueryMsg::Greet {}).unwrap();
        let resp: GreetResp = from_binary(&amp;resp).unwrap();
        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}</code></pre>
<p>这里有一些新的东西。首先，我将 <code>deps</code> 和 <code>env</code> 提取到它们自己的变量中，并将它们传递给调用。这个想法是，这些变量表示一些区块链的持久状态，我们不想为每次调用都创建它们。我们希望在 <code>instantiate</code> 中发生的任何对合</p>
<p>约状态的更改都可以在 <code>query</code> 中看到。而且，我们希望能够控制查询和实例化中的环境差异。</p>
<p><code>info</code> 参数是另一个问题。消息信息对于每个发送的消息都是唯一的。为了创建模拟的 <code>info</code>，我们必须将两个参数传递给 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_info.html"><code>mock_info</code></a> 函数。</p>
<p>第一个是执行调用的地址。将 <code>sender</code> 作为地址传递可能看起来有点奇怪，而不是一些神秘的以 <code>wasm</code> 开头的哈希，但这是一个有效的地址。对于测试目的，这样的地址通常更好，因为如果测试失败，它们更为冗长。</p>
<p>第二个参数是与消息一起发送的资金。现在，我们将其设置为空切片，因为我不想讨论令牌转移 - 我们稍后会介绍它。</p>
<p>所以现在它更像是一个真实的用例。我只看到一个问题。我说合约是一个单一的黑盒。但是这里没有任何东西将 <code>instantiate</code> 调用与相应的 <code>query</code> 关联起来。看起来我们假设存在某个全局的合约。但是看起来，如果我们在单个测试用例中希望有两个以不同方式实例化的合约，那将变得混乱。如果有一些工具可以为我们抽象这个，那将是很好的，不是吗？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-multitest"><a class="header" href="#介绍-multitest">介绍 multitest</a></h1>
<p>让我来介绍一下<a href="https://crates.io/crates/cw-multi-test"><code>multitest</code></a>——一个用于在 Rust 中为智能合约创建测试的库。</p>
<p><code>multitest</code> 的核心思想是抽象出合约的实体，并模拟区块链环境以进行测试。其目的是测试智能合约之间的通信。它的功能非常出色，同时也是测试单一合约场景的绝佳工具。</p>
<p>首先，我们需要在<code>Cargo.toml</code>中添加 multitest 作为依赖。</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>我添加了一个新的<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a>部分，用于存放在最终二进制文件中不会使用到但在开发过程中可能被工具使用的依赖项，例如测试。</p>
<p>当我们准备好依赖项后，更新我们的测试以使用这个框架：</p>
<pre><code class="language-rust noplayground">#[allow(dead_code)]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty
) -&gt; StdResult&lt;Response&gt; {
    unimplemented!()
}

#[cfg(test)]
mod tests {
    use cosmwasm_std::Addr;
    use cw_multi_test::{App, ContractWrapper, Executor};

    use super::*;

    #[test]
    fn greet_query() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;Empty {},
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: GreetResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
            .unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}</code></pre>
<p>你可能注意到我添加了一个 <code>execute</code> 入口函数。我没有添加入口点本身或函数的实现，但为了进行 multitest，合约必须包含至少 <code>instantiate</code>、<code>query</code> 和 <code>execute</code> 处理程序。我将该函数标记为<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#lint-check-attributes"><code>#[allow(dead_code)]</code></a>，这样 <code>cargo</code> 就不会抱怨它没有在任何地方使用。只在测试中启用它，使用 <code>#[cfg(test)]</code> 也是一种方式。</p>
<p>然后在测试的开头，我创建了一个 <a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#"><code>App</code></a> 对象。它是 multitest 中代表虚拟区块链的核心实体。正如你所看到的，我们可以像使用 <code>wasmd</code> 一样在其上调用函数与区块链进行交互！</p>
<p>在创建 <code>app</code> 后，我准备了一个代表要在区块链上 &quot;上传&quot; 的 <code>code</code> 表示。由于 multitest 只是原生的 Rust 测试，并不涉及任何 Wasm 二进制文件，但这个名称与真实场景非常匹配。我们使用 <a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#method.store_code"><code>store_code</code></a> 函数将该对象存储在区块链上，并获得代码的 ID - 我们将需要它来实例化合约。</p>
<p>接下来是实例化的步骤。在单个<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/trait.Executor.html#method.instantiate_contract"><code>instantiate_contract</code></a>调用中，我们提供了与 <code>wasmd</code> 相同的一切 - 合约代码 ID、执行实例化的地址、触发实例化的消息以及随消息发送的任何资金（现在为空）。我们添加了合约的标签和迁移的管理员 - <code>None</code>，因为我们还不需要它。</p>
<p>合约上线后，我们可以对其进行查询。<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html?search=in#method.wrap"><code>wrap</code></a>函数是用于查询 API 的访问器（查询与其他调用的处理方式略有不同），而<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.QuerierWrapper.html#method.query_wasm_smart"><code>query_wasm_smart</code></a>查询需要合约和消息作为参数。此外，我们不需要关心查询结果是否为 <code>Binary</code> - multitest 假设我们希望将其反序列化为某个响应类型，因此它利用了 Rust 的类型推断优势，为我们提供了良好的 API。</p>
<p>现在是重新运行测试的时候了。它应该仍然通过，但现在我们已经将整个测试合约进行了良好的抽象，而不仅仅是一些内部函数。下一步，我们可能应该让合约变得更有趣，通过添加一些状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合同状态"><a class="header" href="#合同状态">合同状态</a></h1>
<p>我们正在进行的合同已经有一些能够回答查询的行为。不幸的是，它的回答非常可预测，而且没有任何东西可以改变它们。在这一章，我引入了状态的概念，这将使我们能够真正地给智能合同带来生命。</p>
<p>目前的状态仍然是静态的 - 它将在合同实例化时初始化。状态将包含一份管理员列表，这些管理员在未来有资格执行消息。</p>
<p>首先要做的是更新<code>Cargo.toml</code>，增加另一个依赖项 - <a href="https://crates.io/crates/cw-storage-plus"><code>storage-plus</code></a> crate，它为CosmWasm智能合同状态管理提供了高级绑定：</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>现在创建一个新文件，用来保存合同的状态 - 我们通常称之为<code>src/state.rs</code>：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_storage_plus::Item;

pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);</code></pre>
<p>并确保在<code>src/lib.rs</code>中声明模块：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">mod contract;
</span><span class="boring">mod msg;
</span>mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(deps: DepsMut, env: Env, info: MessageInfo, msg: Empty)
</span><span class="boring">  -&gt; StdResult&lt;Response&gt;
</span><span class="boring">{
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg)
</span><span class="boring">  -&gt; StdResult&lt;Binary&gt;
</span><span class="boring">{
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}</span></code></pre>
<p>我们在这里的新东西是<code>ADMINS</code>常量，类型是<code>Item&lt;Vec&lt;Addr&gt;&gt;</code>。你可以在这里问一个很好的问题 - 状态是如何保持恒定的？如果它是一个常数值，我如何修改它？</p>
<p>答案有点复杂 - 这个常数并不是保持状态本身的。状态是存储在区块链中的，通过传递给入口点的<code>deps</code>参数进行访问。storage-plus常量只是访问器工具，帮助我们以结构化的方式访问这个状态。</p>
<p>在CosmWasm中，区块链状态只是一个巨大的键值存储。键以元信息为前缀，指向</p>
<p>拥有它们的合同（所以没有其他合同可以以任何方式改变它们），但即使去掉前缀，单个合同状态也是一个较小的键值对。</p>
<p><code>storage-plus</code>通过智能地为项目键额外添加前缀来处理更复杂的状态结构。现在，我们只是使用了最简单的存储实体 - 一个<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html"><code>Item&lt;_&gt;</code></a>，它保存了一个给定类型的单个可选值 - 在这种情况下是<code>Vec&lt;Addr&gt;</code>。那么在存储中这个项目的键是什么呢？这对我们来说无关紧要 - 它会被发现是唯一的，基于传递给<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.new"><code>new</code></a>函数的唯一字符串。</p>
<p>在我们开始初始化我们的状态之前，我们需要一些更好的实例化消息。转到<code>src/msg.rs</code>并创建一个：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">}</span></code></pre>
<p>现在前进到<code>src/contract.rs</code>中的实例化入口点，并将我们的状态初始化为我们在实例化消息中得到的任何内容：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, InstantiateMsg, QueryMsg};
</span>use crate::state::ADMINS;
// --snip--
<span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span>pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
        .admins
        .into_iter()
        .map(|addr| deps.api.addr_validate(&amp;addr))
        .collect();
    ADMINS.save(deps.storage, &amp;admins?)?;

    Ok(Response::new())
}
<span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;Empty {},
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>我们还需要在<code>src/lib.rs</code>中的入口点更新消息类型：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span>use msg::InstantiateMsg;
// --snip--
<span class="boring">
</span><span class="boring">mod contract;
</span><span class="boring">mod msg;
</span><span class="boring">mod state;
</span><span class="boring">
</span>#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}</span></code></pre>
<p>瞧，这就是更新状态所需要的全部内容！</p>
<p>首先，我们需要将字符串的向量转换为要存储的地址的向量。我们不能把地址作为消息参数，因为并非每个字符串都是一个有效的地址。当我们在测试上工作时，这可能有点令人困惑。任何字符串都可以在地址的位置使用。让我解释一下。</p>
<p>从技术上讲，每个字符串都可以被认为是一个地址。然而，并非每个字符串都是实际存在的区块链地址。当我们在合同中保存任何类型的<code>Addr</code>时，我们假设它是区块链中的一个合适的地址。这就是为什么<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/trait.Api.html#tymethod.addr_validate"><code>addr_validate</code></a>函数存在的原因 - 用来检查这个前提条件。</p>
<p>有了要存储的数据，我们使用<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.save"><code>save</code></a>函数将其写入合同状态。注意<code>save</code>的第一个参数是<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/trait.Storage.html"><code>&amp;mut Storage</code></a>，这是实际的区块链存储。正如强调的那样，<code>Item</code>对象不存储任何东西，只是一个访问器。它确定如何在给定的存储中存储数据。第二个参数是要存储的可序列化数据。</p>
<p>现在是检查我们通过的回归测试的好时机 - 尝试运行我们的测试：</p>
<pre><code>&gt; cargo test

...

running 1 test
test contract::tests::greet_query ... FAILED

failures:

---- contract::tests::greet_query stdout ----
thread 'contract::tests::greet_query' panicked at 'called `Result::unwrap()` on an `Err` value: error executing WasmMsg:
sender: owner
Instantiate { admin: None, code_id: 1, msg: Binary(7b7d), funds: [], label: &quot;Contract&quot; }

Caused by:
    Error parsing into type contract::msg::InstantiateMsg: missing field `admins`', src/contract.rs:80:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    contract::tests::greet_query

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>哎呀，我们把什么东西弄坏了！但请保持冷静。让我们从仔细阅读错误消息开始：</p>
<blockquote>
<p>Error parsing into type contract::msg::InstantiateMsg: missing field <code>admins</code>', src/contract.rs:80:14</p>
</blockquote>
<p>问题是，在测试中，我们在测试中发送了一个空的实例化消息，但现在，我们的端点期望有一个<code>admin</code>字段。多测试框架从入口点到结果测试合同，所以使用MT函数发送消息首先会对它们进行序列化。然后合同在入口处对它们进行反序列化。但现在它试图把空的JSON反序列化为一些非空的消息！我们可以通过更新测试快速修复它：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greet_query() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: GreetResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
            .unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
<span class="boring">}</span></code></pre>
<h2 id="测试状态"><a class="header" href="#测试状态">测试状态</a></h2>
<p>当状态被初始化时，我们希望有一种方式来测试它。我们希望提供一个查询来检查实例化是否影响了状态。只需创建一个简单的查询来列出所有的管理员。首先在<code>src/msg.rs</code>中为查询消息和相应的响应消息添加一个变量。我们将变量命名为<code>AdminsList</code>，响应为<code>AdminsListResp</code>，并让它返回一个<code>cosmwasm_std::Addr</code>的向量：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct AdminsListResp  {
    pub admins: Vec&lt;Addr&gt;,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}</code></pre>
<p>并在其中实施 <code>src/contract.rs</code>:</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
    }
}
 
<span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span>mod query {
<span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">       let resp = GreetResp {
</span><span class="boring">           message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       Ok(resp)
</span><span class="boring">   }
</span><span class="boring">
</span>    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
        let admins = ADMINS.load(deps.storage)?;
        let resp = AdminsListResp { admins };
        Ok(resp)
    }
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">       let mut app = App::default();
</span><span class="boring">
</span><span class="boring">       let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">       let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">       let addr = app
</span><span class="boring">           .instantiate_contract(
</span><span class="boring">               code_id,
</span><span class="boring">               Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">               &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">               &amp;[],
</span><span class="boring">               &quot;Contract&quot;,
</span><span class="boring">               None,
</span><span class="boring">           )
</span><span class="boring">           .unwrap();
</span><span class="boring">
</span><span class="boring">       let resp: GreetResp = app
</span><span class="boring">           .wrap()
</span><span class="boring">           .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">           .unwrap();
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           GreetResp {
</span><span class="boring">               message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>现在我们有了测试实例的工具，让我们编写一个测试用例：</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn instantiation() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: AdminsListResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
            .unwrap();

        assert_eq!(resp, AdminsListResp { admins: vec![] });

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
                },
                &amp;[],
                &quot;Contract 2&quot;,
                None,
            )
            .unwrap();

        let resp: AdminsListResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
            .unwrap();

        assert_eq!(
            resp,
            AdminsListResp {
                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
            }
        );
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span>}</code></pre>
<p>测试很简单 - 用不同的初始管理员两次实例化合同，并确保每次的查询结果都是正确的。这通常是我们测试合同的方式 - 我们在合同上执行一堆消息，然后我们查询一些数据，验证查询响应是否符合预期。</p>
<p>我们在开发合同方面做得很好。现在是时候使用状态并允许一些执行了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="执行消息"><a class="header" href="#执行消息">执行消息</a></h1>
<p>我们已经了解了实例化和查询消息。现在终于到了介绍最后一个基本入口点 - 执行消息的时候了。这与我们迄今为止所做的类似，我希望这只是放松和复习我们的知识。我鼓励你尝试自己实现我在这里描述的内容作为一个练习 - 不需要查看源代码。</p>
<p>合同的想法很简单 - 每个合同管理员都有资格调用两个执行消息：</p>
<ul>
<li><code>AddMembers</code>消息将允许管理员向管理员列表中添加另一个地址</li>
<li><code>Leave</code>将允许管理员从列表中删除自己</li>
</ul>
<p>不太复杂。让我们开始编码。从定义消息开始：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">    AdminsList {},
</span><span class="boring">}</span></code></pre>
<p>实现入口点：</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span> 
#[allow(dead_code)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; StdResult&lt;Response&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info),
    }
}

mod exec {
    use cosmwasm_std::StdError;

    use super::*;

    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; StdResult&lt;Response&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(StdError::generic_err(&quot;Unauthorised access&quot;));
        }

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(Response::new())
    }

    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
            let admins = admins
                .into_iter()
                .filter(|admin| *admin != info.sender)
                .collect();
            Ok(admins)
        })?;

        Ok(Response::new())
    }
}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>入口点本身也必须被创建 <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};

mod contract;
mod msg;
mod state;

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}

#[entry_point]
pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -&gt; StdResult&lt;Response&gt; {
    contract::execute(deps, env, info, msg)
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    contract::query(deps, env, msg)
}</code></pre>
<p>有几个新东西，但没有什么特别的。首先是我如何接触到消息发送者，以验证他是否是管理员或者从列表中删除他 - 我使用了<code>MessageInfo</code>的<code>info.sender</code>字段，这就是它的样子 - 成员。由于消息总是从适当的地址发送的，<code>sender</code>已经是<code>Addr</code>类型 - 无需验证它。另一个新东西是<code>Item</code>上的<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.update"><code>update</code></a>函数 - 它使得实体的读取和更新更加高效。可以通过首先读取管理员，然后更新和存储结果来做到这一点。</p>
<p>你可能已经注意到，当我们使用<code>Item</code>时，我们总是假设有什么东西在那里。但是没有什么强迫我们在实例化时初始化<code>ADMINS</code>值！那么那里发生了什么？好吧，<code>load</code>和<code>update</code>函数都会返回一个错误。但是有一个<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.may_load"><code>may_load</code></a>函数，它返回<code>StdResult&lt;Option&lt;T&gt;&gt;</code> - 在存储为空的情况下，它会返回<code>Ok(None)</code>。甚至有可能通过<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.remove"><code>remove</code></a>函数从存储中删除现有的项目。</p>
<p>需要改进的一点是错误处理。在验证发送者是否为管理员时，我们返回一些任意字符串作为错误。我们可以做得更好。</p>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>在我们的合同中，现在有一个错误情况，当一个用户试图执行<code>AddMembers</code>而他自己不是管理员时。在<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/enum.StdError.html"><code>StdError</code></a>中没有适当的错误情况来报告这种情况，所以我们必须返回一个带有消息的通用错误。这不是最好的方法。</p>
<p>对于错误报告，我们鼓励使用<a href="https://crates.io/crates/thiserror/1.0.24/dependencies"><code>thiserror</code></a>包。首先更新你的依赖：</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;
thiserror = &quot;1&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>现在我们定义一个错误类型 <code>src/error.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    StdError(#[from] StdError),
    #[error(&quot;{sender} is not contract admin&quot;)]
    Unauthorized { sender: Addr },
}</code></pre>
<p>我们还需要将新模块添加到 <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span>mod contract;
mod error;
mod msg;
mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::execute(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}</span></code></pre>
<p>使用<code>thiserror</code>库，我们可以像定义简单枚举一样定义错误类型，并且该库会确保该类型实现了<a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait。该库的一个非常好的特性是通过<code>#[error]</code>属性内联定义了<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> trait。另外，还有一个有用的特性是<code>#[from]</code>属性，它会自动生成适当的<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>实现，因此在使用<code>thiserror</code>类型时可以轻松使用<code>?</code>操作符。</p>
<p>现在更新执行端点，使用我们的新错误类型：</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span> 
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
    }
}

mod exec {
    use super::*;

    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(Response::new())
    }
<span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>入口点的返回类型也必须更新：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span>use error::ContractError;
<span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span>
<span class="boring">mod contract;
</span><span class="boring">mod error;
</span><span class="boring">mod msg;
</span><span class="boring">mod state;
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    contract::execute(deps, env, info, msg)
}
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}</span></code></pre>
<h2 id="自定义错误和多重测试"><a class="header" href="#自定义错误和多重测试">自定义错误和多重测试</a></h2>
<p>使用正确的自定义错误类型有一个很好的好处-<code>multi-test</code>使用<a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>库来维护错误类型。<code>anyhow</code>是<code>thiserror</code>的兄弟库，旨在以一种允许获取原始错误的方式实现类型擦除错误。</p>
<p>让我们编写一个测试来验证非管理员不能将自己添加到列表中：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn unauthorized() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let err = app
            .execute_contract(
                Addr::unchecked(&quot;user&quot;),
                addr,
                &amp;ExecuteMsg::AddMembers {
                    admins: vec![&quot;user&quot;.to_owned()],
                },
                &amp;[],
            )
            .unwrap_err();

        assert_eq!(
            ContractError::Unauthorized {
                sender: Addr::unchecked(&quot;user&quot;)
            },
            err.downcast().unwrap()
        );
    }
}</code></pre>
<p>执行合约与任何其他调用非常相似-我们使用<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/trait.Executor.html#method.execute_contract"><code>execute_contract</code></a>函数。由于执行可能会失败，我们会得到一个错误类型的返回值，但是我们不会调用<code>unwrap</code>来提取其中的值，而是期望出现一个错误-这就是<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err</code></a>的用途。现在，我们有了一个错误值，我们可以使用<code>assert_eq!</code>来检查它是否符合我们的预期。这里有一个小的复杂之处-<code>execute_contract</code>返回的错误是一个<a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html"><code>anyhow::Error</code></a>错误，但是我们期望它是一个<code>ContractError</code>。幸运的是，正如我之前所说，<code>anyhow</code>错误可以使用<a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html#method.downcast"><code>downcast</code></a>函数恢复其原始类型。紧随其后的<code>unwrap</code>是必需的，因为类型转换可能失败。原因是<code>downcast</code>并不知道底层错误中保存的类型，它通过一些上下文推断出来-在这里，它知道我们期望它是一个<code>ContractError</code>，因为进行了比较-类型推断的奇迹。但是，如果底层错误不是<code>ContractError</code>，那么<code>unwrap</code>将会引发恐慌。</p>
<p>我们刚刚为执行创建了一个简单的失败测试，但这还不足以宣称该合约已经适用于生产环境。为了达到这个目标，所有合理的正常情况都应该被覆盖到。我鼓励您在本章结束后作为练习创建一些测试并进行实验。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件属性和数据"><a class="header" href="#事件属性和数据">事件属性和数据</a></h1>
<p>目前，我们合约与外界进行通信的唯一方式是通过查询。智能合约是被动的，它们不能自行调用任何操作。它们只能作为对调用的反应而执行。但是，如果您尝试过与wasmd进行交互，您就会知道在区块链上执行可以返回一些元数据。</p>
<p>合约可以向调用者返回两种内容：事件和数据。几乎每个现实生活中的智能合约都会产生事件。相比之下，数据很少使用，设计用于合约之间的通信。</p>
<h2 id="返回事件"><a class="header" href="#返回事件">返回事件</a></h2>
<p>作为示例，我们将在执行<code>AddMembers</code>时，由我们的合约发出一个名为<code>admin_added</code>的事件：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span>use cosmwasm_std::{
    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
};
 
<span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>mod exec {
<span class="boring">    use super::*;
</span><span class="boring">
</span>    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }

        let events = admins
            .iter()
            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
        let resp = Response::new()
            .add_events(events)
            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
            .add_attribute(&quot;added_count&quot;, admins.len().to_string());

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(resp)
    }
<span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>事件由两部分构成：在<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.new"><code>new</code></a>函数中提供的事件类型和属性。属性可以通过<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.add_attributes"><code>add_attributes</code></a>或<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.add_attribute"><code>add_attribute</code></a>方法将其添加到事件中。属性是键值对。由于事件不能包含任何列表，为了报告多个类似的事件，我们需要发出多个小事件而不是一个集合性的事件。</p>
<p>通过使用<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.add_event"><code>add_event</code></a>或<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.add_events"><code>add_events</code></a>方法将事件添加到响应中来发出事件。此外，还可以直接将属性添加到响应中。这只是一种简化方式。默认情况下，每次执行都会发出一个标准的&quot;wasm&quot;事件。将属性添加到结果中会将它们添加到默认事件中。</p>
<p>我们可以检查合约是否正确发出了事件。这并不总是在测试中完成的，因为它在测试中往往是样板代码，而事件通常更像日志-并不一定被视为主要的合约逻辑。现在，让我们编写一个测试，检查执行是否发出了事件：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn add_members() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;owner&quot;.to_owned()],
                },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp = app
            .execute_contract(
                Addr::unchecked(&quot;owner&quot;),
                addr,
                &amp;ExecuteMsg::AddMembers {
                    admins: vec![&quot;user&quot;.to_owned()],
                },
                &amp;[],
            )
            .unwrap();

        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
        assert_eq!(
            wasm.attributes
                .iter()
                .find(|attr| attr.key == &quot;action&quot;)
                .unwrap()
                .value,
            &quot;add_members&quot;
        );
        assert_eq!(
            wasm.attributes
                .iter()
                .find(|attr| attr.key == &quot;added_count&quot;)
                .unwrap()
                .value,
            &quot;1&quot;
        );

        let admin_added: Vec&lt;_&gt; = resp
            .events
            .iter()
            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
            .collect();
        assert_eq!(admin_added.len(), 1);

        assert_eq!(
            admin_added[0]
                .attributes
                .iter()
                .find(|attr| attr.key == &quot;addr&quot;)
                .unwrap()
                .value,
            &quot;user&quot;
        );
    }
}</code></pre>
<p>正如您所见，在简单的测试中测试事件变得有些笨拙。首先，每个字符串都以字符串为基础-缺乏类型控制使得编写此类测试困难。而且，即使类型带有&quot;wasm-&quot;前缀-这可能不是一个很大的问题，但它并没有澄清验证的意义。但问题是，事件结构有多层，这使得验证它们变得棘手。而且，&quot;wasm&quot;事件特别棘手，因为它包含一个暗含的属性-<code>_contract_addr</code>，其中包含一个称为合约的地址。我的一般规则是-除非某些逻辑依赖于它们，否则不要测试发出的事件。</p>
<h2 id="数据"><a class="header" href="#数据">数据</a></h2>
<p>除了事件之外，任何智能合约执行都可以产生一个<code>data</code>对象。与事件不同，<code>data</code>可以是结构化的。这使得它成为执行任何依赖于通信逻辑的更好选择。另一方面，事实证明，在合约之间的通信之外，它很少有帮助。<code>data</code>始终只是响应中的单个对象，可以使用<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.set_data"><code>set_data</code></a>函数设置。由于在单个合约环境中它的用处较低，我们现在不会花时间详细讨论它-稍后在讨论合约之间通信时将涵盖它的示例。在那之前，了解这样的实体存在是有帮助的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理资金"><a class="header" href="#处理资金">处理资金</a></h1>
<p>当您听到智能合约时，您会想到区块链。当您听到区块链时，您通常会想到加密货币。虽然它们并不完全相同，但加密资产，或者我们通常称之为代币，与区块链非常密切相关。CosmWasm有一个本地代币的概念。本地代币是由区块链核心而不是智能合约管理的资产。通常，这种资产具有一些特殊含义，比如用于支付<a href="https://docs.cosmos.network/master/basics/gas-fees.html">燃气费</a>或<a href="https://en.wikipedia.org/wiki/Proof_of_stake">权益证明</a>共识算法，但也可以是任意的资产。</p>
<p>本地代币分配给它们的所有者，但可以根据其性质进行转移。在区块链中，每个具有地址的事物都有资格拥有其本地代币。因此 - 代币可以分配给智能合约！发送到智能合约的每个消息都可以携带一些资金。在本章中，我们将利用这一点创建一种奖励管理员辛勤工作的方式。我们将创建一条新消息 - <code>Donate</code>，任何人都可以使用它向管理员捐赠一些资金，并平均分配。</p>
<h2 id="准备消息"><a class="header" href="#准备消息">准备消息</a></h2>
<p>传统上，我们需要准备我们的消息。我们需要创建一个新的<code>ExecuteMsg</code>变体，但我们还将稍微修改<code>Instantiate</code>消息 - 我们需要有一种定义用于捐款的本地代币名称的方式。用户可以发送任何他们想要的代币，但现在我们想简化事情。</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">    AdminsList {},
</span><span class="boring">}</span></code></pre>
<p>我们还需要添加一个新的状态部分，以保留<code>donation_denom</code>（捐赠代币名称）：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_storage_plus::Item;

pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);</code></pre>
<p>并适当地进行实例化：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span>use crate::state::{ADMINS, DONATION_DENOM};
<span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span>
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
        .admins
        .into_iter()
        .map(|addr| deps.api.addr_validate(&amp;addr))
        .collect();
    ADMINS.save(deps.storage, &amp;admins?)?;
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>还需要对测试进行一些修正 - 实例化消息有一个新字段。我将其留给您作为一个练习。
现在，我们已经拥有了实现向管理员捐赠资金所需的一切。首先，对<code>Cargo.toml</code>进行一个小的更新 - 我们将使用一个额外的实用包：</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;
thiserror = &quot;1&quot;
schemars = &quot;0.8.1&quot;
cw-utils = &quot;0.13&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
cosmwasm-schema = { version = &quot;1.0.0&quot; }
</code></pre>
<p>然后我们可以实现捐赠处理程序：</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span>use cosmwasm_std::{
    coins, to_binary, BankMsg, Binary, Deps, DepsMut, Env, Event, MessageInfo,
    Response, StdResult,
};
 
<span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
        Donate {} =&gt; exec::donate(deps, info),
    }
}

mod exec {
<span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
        let denom = DONATION_DENOM.load(deps.storage)?;
        let admins = ADMINS.load(deps.storage)?;

        let donation = cw_utils::must_pay(&amp;info, &amp;denom)?.u128();

        let donation_per_admin = donation / (admins.len() as u128);

        let messages = admins.into_iter().map(|admin| BankMsg::Send {
            to_address: admin.to_string(),
            amount: coins(donation_per_admin, &amp;denom),
        });

        let resp = Response::new()
            .add_messages(messages)
            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
            .add_attribute(&quot;amount&quot;, donation.to_string())
            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

        Ok(resp)
    }
}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>将资金发送到另一个合约是通过在响应中添加银行消息来完成的。区块链期望在合约响应中返回的任何消息都作为执行的一部分。这个设计与CosmWasm实现的actor模型相关。整个actor模型将在稍后详细描述。目前，您可以将其视为处理代币转账的一种方式。在将代币发送给管理员之前，我们必须计算每个管理员的捐款金额。这是通过搜索描述我们的捐款代币的条目，并将发送的代币数量除以管理员数量来完成的。请注意，由于整数除法总是向下取整。</p>
<p>因此，可能并非所有作为捐款发送的代币都会最终分配给管理员账户。任何剩余的代币都将永远留在我们的合约账户上。有很多方法可以解决这个问题 - 找到其中一种方法将是一个很好的练习。</p>
<p>最后一个缺失的部分是更新<code>ContractError</code> - <code>must_pay</code>调用返回了一个我们尚不能转换为我们的错误类型的<code>cw_utils::PaymentError</code>：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use cw_utils::PaymentError;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    StdError(#[from] StdError),
    #[error(&quot;{sender} is not contract admin&quot;)]
    Unauthorized { sender: Addr },
    #[error(&quot;Payment error: {0}&quot;)]
    Payment(#[from] PaymentError),
}</code></pre>
<p>正如您所见，为了处理进入的资金，我使用了实用函数 - 我鼓励您查看<a href="https://docs.rs/cw-utils/0.13.4/src/cw_utils/payment.rs.html#32-39">其实现</a> - 这将让您对<code>MessageInfo</code>中的进入资金的结构有很好的理解。</p>
<p>现在是时候检查资金是否被正确分配了。为此，我们可以编写一个测试。</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    coins, to_binary, BankMsg, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">        Donate {} =&gt; exec::donate(deps, info),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let denom = DONATION_DENOM.load(deps.storage)?;
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">
</span><span class="boring">        let donation = cw_utils::must_pay(&amp;info, &amp;denom)
</span><span class="boring">            .map_err(|err| StdError::generic_err(err.to_string()))?
</span><span class="boring">            .u128();
</span><span class="boring">
</span><span class="boring">        let donation_per_admin = donation / (admins.len() as u128);
</span><span class="boring">
</span><span class="boring">        let messages = admins.into_iter().map(|admin| BankMsg::Send {
</span><span class="boring">            to_address: admin.to_string(),
</span><span class="boring">            amount: coins(donation_per_admin, &amp;denom),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_messages(messages)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
</span><span class="boring">            .add_attribute(&quot;amount&quot;, donation.to_string())
</span><span class="boring">            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn donations() {
        let mut app = App::new(|router, _, storage| {
            router
                .bank
                .init_balance(storage, &amp;Addr::unchecked(&quot;user&quot;), coins(5, &quot;eth&quot;))
                .unwrap()
        });

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
                    donation_denom: &quot;eth&quot;.to_owned(),
                },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        app.execute_contract(
            Addr::unchecked(&quot;user&quot;),
            addr.clone(),
            &amp;ExecuteMsg::Donate {},
            &amp;coins(5, &quot;eth&quot;),
        )
        .unwrap();

        assert_eq!(
            app.wrap()
                .query_balance(&quot;user&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            0
        );

        assert_eq!(
            app.wrap()
                .query_balance(&amp;addr, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            1
        );

        assert_eq!(
            app.wrap()
                .query_balance(&quot;admin1&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            2
        );

        assert_eq!(
            app.wrap()
                .query_balance(&quot;admin2&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            2
        );
    }
}</code></pre>
<p>相当简单。我并不特别喜欢每个余额检查都有八行代码，但是可以通过将这个断言封装到一个单独的函数中来改进，可能需要使用<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-track_caller-attribute"><code>#[track_caller]</code></a>属性。</p>
<p>需要讨论的关键问题是<code>app</code>创建的变化。因为我们需要在<code>user</code>账户上有一些初始代币，所以不能使用默认构造函数，而是必须提供一个初始化函数。不幸的是，<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#method.new"><code>new</code></a>的文档不容易理解，即使函数本身并不复杂。它作为参数接受一个闭包，有三个参数——包含multi-test支持的所有模块的<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.Router.html"><code>Router</code></a>、API对象和状态。这个函数在合约实例化时只被调用一次。<code>router</code>对象包含一些通用字段，我们特别关注<code>bank</code>。它的类型是<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.BankKeeper.html"><code>BankKeeper</code></a>，其中包含<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.BankKeeper.html#method.init_balance"><code>init_balance</code></a>函数。</p>
<h2 id="惊喜"><a class="header" href="#惊喜">惊喜！</a></h2>
<p>由于我们已经介绍了构建Rust智能合约的大部分重要基础知识，我给你出了一个严肃的练习。</p>
<p>我们构建的合约有一个可以被利用的漏洞。所有的捐赠款项都平均分配给管理员。然而，每个管理员都有资格添加另一个管理员。而且没有任何限制阻止管理员将自己添加到列表中并获得其他人两倍的奖励！</p>
<p>请尝试编写一个能检测到这种漏洞的测试，并修复它，确保该漏洞不再发生。</p>
<p>即使管理员不能将相同的地址添加到列表中，他仍然可以创建新的账户并将它们添加进去，但这是在合约层面上无法阻止的，所以不要阻止这种情况的发生。处理这种情况是通过正确设计整个应用程序来完成的，超出了本章的范围。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="良好的实践"><a class="header" href="#良好的实践">良好的实践</a></h1>
<p>所有相关的基础知识都已经介绍完了。现在让我们讨论一些良好的实践。</p>
<h2 id="json-命名重命名"><a class="header" href="#json-命名重命名">JSON 命名重命名</a></h2>
<p>由于 Rust 的风格，我们所有的消息变体都使用 <a href="https://en.wikipedia.org/wiki/CamelCase">驼峰命名法</a>。这是标准的做法，但它有一个缺点 - 所有的消息都通过 serde 进行序列化和反序列化，使用这些变体名称。问题是，在 JSON 世界中，更常见的是使用 <a href="https://en.wikipedia.org/wiki/Snake_case">蛇形命名法</a> 来命名字段。幸运的是，有一种简单的方法告诉 serde，在序列化时更改字段的命名方式。让我们使用 <code>#[serde]</code> 属性更新我们的消息：</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}</code></pre>
<h2 id="json-schema"><a class="header" href="#json-schema">JSON schema</a></h2>
<p>谈到 JSON API，值得提到 JSON Schema。它是一种定义 JSON 消息结构的方式。
为合约 API 提供生成模式的方法是良好的实践。问题在于手动编写 JSON 模式很麻烦。好消息是有一个 crate 可以帮助我们。打开 <code>Cargo.toml</code> 文件：</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1.4&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.15.1&quot;
thiserror = &quot;1&quot;
schemars = &quot;0.8.1&quot;
cosmwasm-schema = &quot;1.1.4&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>在这个文件中还有一个额外的更改 - 在 <code>crate-type</code> 中我添加了 &quot;rlib&quot;。&quot;cdylib&quot; crate 不能像典型的 Rust 依赖一样使用。因此，无法为这样的 crate 创建示例。</p>
<p>现在回到 <code>src/msg.rs</code> 并为所有消息添加一个新的派生：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use schemars::JsonSchema;
<span class="boring">use serde::{Deserialize, Serialize};
</span>
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}</code></pre>
<p>你可能会认为所有这些派生看起来有些笨拙，我同意这个观点。
幸运的是，<a href="https://docs.rs/cosmwasm-schema/1.1.4/cosmwasm_schema/#"><code>cosmwasm-schema</code></a> crate 提供了一个实用的 <code>cw_serde</code> 宏，我们可以使用它来减少样板代码：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use cosmwasm_schema::cw_serde

#[cw_serde]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[cw_serde]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[cw_serde]
pub struct GreetResp {
    pub message: String,
}

#[cw_serde]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[cw_serde]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}</code></pre>
<p>另外，我们还必须为我们的查询消息派生额外的 <code>QueryResponses</code> trait，以将消息变体与我们为其生成的响应相关联：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use cosmwasm_schema::{cw_serde, QueryResponses}

<span class="boring">#[cw_serde]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">    pub donation_denom: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub enum ExecuteMsg {
</span><span class="boring">    AddMembers { admins: Vec&lt;String&gt; },
</span><span class="boring">    Leave {},
</span><span class="boring">    Donate {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(GreetResp)]
    Greet {},
    #[returns(AdminsListResp)]
    AdminsList {},
}</code></pre>
<p><code>QueryResponses</code> 是一个 trait，要求为所有查询变体添加 <code>#[returns(...)]</code> 属性，以生成关于查询-响应关系的额外信息。</p>
<p>现在，我们希望将 <code>msg</code> 模块公开并允许依赖于我们合约的 crate 访问（在本例中用于模式示例）。请更新 <code>src/lib.rs</code>：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use error::ContractError;
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span>pub mod contract;
pub mod error;
pub mod msg;
pub mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    contract::execute(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}</span></code></pre>
<p>我更改了所有模块的可见性 - 因为我们的 crate 现在可以作为依赖项使用。
如果有人想这样做，他可能需要访问处理程序或状态。</p>
<p>下一步是创建一个生成实际模式的工具。我们将通过在我们的 crate 中创建一个二进制文件来实现这个目标。创建一个新的 <code>bin/schema.rs</code> 文件：</p>
<pre><code class="language-rust noplayground">use contract::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use cosmwasm_schema::write_api;

fn main() {
    write_api! {
        instantiate: InstantiateMsg,
        execute: ExecuteMsg,
        query: QueryMsg
    }
}</code></pre>
<p>Cargo足够智能，能够识别<code>src/bin</code>目录中的文件作为该crate的实用程序二进制文件。现在我们可以生成我们的模式了：</p>
<pre><code>$ cargo run schema
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/schema schema`
Removing &quot;/home/hashed/confio/git/book/examples/03-basics/schema/contract.json&quot; …
Exported the full API as /home/hashed/confio/git/book/examples/03-basics/schema/contract.json
</code></pre>
<p>我鼓励你打开生成的文件，看看模式是什么样子的。</p>
<p>问题是，不幸的是，创建这个二进制文件会导致我们的项目在Wasm目标上无法编译 - 最终，这是最重要的一个目标。幸运的是，我们不需要为Wasm目标构建模式二进制文件 - 让我们调整<code>.cargo/config</code>文件：</p>
<pre><code class="language-toml">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release --lib&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown --lib&quot;
schema = &quot;run schema&quot;
</code></pre>
<p>通过向<code>wasm</code>的Cargo别名添加<code>--lib</code>标志，工具链将只构建库目标 - 跳过构建任何二进制文件。此外，我添加了方便的<code>schema</code>别名，这样只需简单地调用<code>cargo schema</code>就可以生成模式。</p>
<h2 id="禁用库的入口点"><a class="header" href="#禁用库的入口点">禁用库的入口点</a></h2>
<p>由于我们为合约添加了 &quot;rlib&quot; 目标，如前所述，它可以作为依赖项使用。问题是，依赖于我们的合约会在依赖项和最终合约中生成两次Wasm入口点。为了解决这个问题，我们可以通过在作为依赖项使用时禁用生成Wasm入口点来解决。我们可以使用<a href="https://doc.rust-lang.org/cargo/reference/features.html">feature标志</a>来实现这一点。</p>
<p>首先更新 <code>Cargo.toml</code> 文件：</p>
<pre><code class="language-toml">[features]
library = []
</code></pre>
<p>通过这种方式，我们为我们的 crate 创建了一个新的 feature。现在我们想要在入口点上禁用 <code>entry_point</code> 属性 - 我们将通过对 <code>src/lib.rs</code> 进行轻微的更新来实现：</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use error::ContractError;
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span><span class="boring">pub mod contract;
</span><span class="boring">pub mod error;
</span><span class="boring">pub mod msg;
</span><span class="boring">pub mod state;
</span><span class="boring">
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}

#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    contract::execute(deps, env, info, msg)
}

#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    contract::query(deps, env, msg)
}</code></pre>
<p><a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> 属性是一个条件编译属性，类似于我们之前用于测试的 <code>cfg</code>。如果条件为 true，则它会扩展为给定的属性。在我们的情况下 - 如果启用了 &quot;library&quot; 特性，它将扩展为空，否则就只会扩展为 <code>#[entry_point]</code>。</p>
<p>由于现在将此合约作为依赖项添加，不要忘记像这样启用特性：</p>
<pre><code class="language-toml">[dependencies]
my_contract = { version = &quot;0.1&quot;, features = [&quot;library&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h1>
<p>现在你已经准备好自己创建智能合约了。是时候讨论一下 CosmWasm 智能合约的一个重要限制 - 浮点数类型。</p>
<p>故事很简单：你不能在智能合约中使用浮点数类型。绝对不行。CosmWasm 虚拟机特意没有实现浮点数的 Wasm 指令，甚至包括诸如 <code>F32Load</code> 这样的基本指令。原因很简单：在区块链世界中，它们不安全。</p>
<p>最大的问题是，合约会编译通过，但上传到区块链时会失败，并显示错误消息，声称合约中存在浮点数操作。用于验证合约是否有效（不包含任何浮点数操作，并且具有所有必需的入口点等）的工具称为 <code>cosmwasm-check</code> <a href="https://github.com/CosmWasm/cosmwasm/tree/main/packages/check">utility</a>。</p>
<p>这个限制有两个影响。首先，你在合约中总是必须使用定点小数算术。这并不是问题，因为 <code>cosmwasm-std</code> 提供了 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Decimal.html"><code>Decimal</code></a> 和 <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Decimal256.html">Decimal256</a> 类型。</p>
<p>另一个问题比较棘手 - 你必须谨慎使用 crate。特别是 <code>serde</code> crate 中的一个坑 - <code>usize</code> 类型的反序列化使用了浮点数操作。这意味着你不能在合约中的反序列化消息中使用 <code>usize</code>（或 <code>isize</code>）类型。</p>
<p>另一个与 serde 不兼容的功能是无标签枚举的反序列化。解决方法是使用 <a href="https://crates.io/crates/serde-cw-value"><code>serde-cw-value</code></a> crate 创建自定义的枚举反序列化。它是 <a href="https://crates.io/crates/serde-value"><code>serde-value</code></a> crate 的分支，避免生成浮点数指令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor模型"><a class="header" href="#actor模型">Actor模型</a></h1>
<p>本节介绍了CosmWasm智能合约架构的基础，它决定了它们之间的通信方式。在逐步教授如何创建彼此相关的多个合约之前，我希望先了解这一点，以便对未来可能遇到的情况有一个初步的了解。如果第一次阅读后仍不清楚，不用担心 - 我建议现在先阅读一遍这一章节，以后在了解了实际部分后再来回顾一下。</p>
<p>这里描述的整个过程在 <code>cosmwasm</code> 仓库的 <a href="https://github.com/CosmWasm/cosmwasm/blob/main/SEMANTICS.md">SEMANTICS.md</a> 中有正式文档记录。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor模型的理念"><a class="header" href="#actor模型的理念">Actor模型的理念</a></h1>
<p>Actor模型是解决智能合约之间通信问题的方案。让我们来看看为什么CosmWasm选择了这种特定的解决方案以及其带来的后果。</p>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<p>智能合约可以被想象为沙盒化的微服务。根据<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则，将责任分散在不同实体之间是有价值的。然而，为了在合约之间分配工作，需要进行通信。因此，如果一个合约负责管理组成员资格，可以从另一个合约调用其功能。</p>
<p>在软件工程中，解决这个问题的传统方法是将服务建模为可以通过某种RPC机制调用的函数，并将其结果作为响应返回。尽管这种方法看起来不错，但它会带来一些问题，特别是与共享状态一致性有关的问题。</p>
<p>在业务级建模中，另一种更流行的方法是将实体视为能够执行某些任务但在调用其他合约时不中断的“actor”。对其他合约的任何调用只能在整个执行完成后进行。当“子调用”完成时，它会回调原始合约。</p>
<p>这种解决方案可能感觉不自然，并且需要不同类型的设计解决方案，但事实证明它非常适用于智能合约执行。我将尝试逐步解释如何进行推理，以及如何将其映射到合约结构。</p>
<h2 id="actor角色"><a class="header" href="#actor角色">Actor角色</a></h2>
<p>整个模型中最重要的是Actor角色本身。那么，它是什么呢？Actor是一个合约的单个实例，可以执行多个操作。当Actor完成工作时，它准备了一个总结，其中包括完成整个预定任务所需的事项列表。</p>
<p>KFC餐厅中的销售员就是一个Actor的例子。首先，您会点餐（BSmart），因此您向销售员请求动作。从系统用户的角度来看，您可以将此任务视为“销售并准备我的餐点”，但销售员执行的动作只是“收取支付并创建订单”。此操作的第一部分是创建账单并向您收取费用，然后它会请求其他Actor（可能是厨师）准备三明治和薯条。然后，当厨师完成他的一部分工作时，他会检查所有餐点是否准备好。如果是这样，他会调用最后一个Actor，即服务员，将食物送到您那里。此时，您可以收到您的外卖，任务被视为已完成。</p>
<p>上述描述的工作流程有些简化。特别是在一家典型的餐厅中，服务员会观察厨房，而不是由厨师触发，但在Actor模型中，这是不可能的。在这里，系统的实体是被动的，不能主动观察环境-它们只能对来自其他系统参与者的消息做出反应。同样在KFC，销售员不会为特定的厨师安排子任务；相反，他们会留下任务，等待厨师有空时接手。这并不是因为厨师不能主动听取环境的原因。但是，可以创建一个合约作为厨师的调度程序，从销售员那里收集所有订单，并在某种情况下将它们分配给厨师。</p>
<h2 id="动作"><a class="header" href="#动作">动作</a></h2>
<p>Actor是模型实体，但为了与它们进行适当的通信，我们需要一种协议。每个Actor都能执行多个动作。在我之前的KFC例子中，销售员唯一能做的动作是“收取支付并创建订单”。然而，并不总是这样-我们的厨师擅长执行“准备薯条”和“准备三明治”等许多动作。</p>
<p>因此，当我们想在Actor系统中做某事时，我们会将某个动作安排给离我们最近的Actor，通常还会带上一些附加参数（例如我们可以选择是否用沙拉替换薯条）。</p>
<p>然而，将动作命名为与合约中发生的确切事情相同的事物会产生误导。再次看看KFC的例子。正如我之前提到的，销售员执行的动作是“收取支付并创建订单”。问题是，对于安排此动作的客户来说，演员本身的责任是什么并不重要-客户安排的是“准备餐点”，并附上一些具体的准备说明。因此，我们可以说，动作是合约本身执行的动作，以及它安排的所有子动作。</p>
<h2 id="多阶段动作"><a class="header" href="#多阶段动作">多阶段动作</a></h2>
<p>整个想法有一定道理，但是在Actor模型中也带来了问题：如果我想在我的合约中执行某个动作，但要完全完成某些步骤，合约必须确保它安排的某些子动作已经完成，怎么办呢？</p>
<p>想象一下，在之前的KFC情景中，没有专门的服务员。相反，当厨师完成他们的工作时，销售员为您提供餐点。</p>
<p>这种模式非常重要和常见，以至于在CosmWasm中，我们开发了一种特殊的处理方式，即专用的<code>Reply</code>动作。</p>
<p>当销售员为厨师安排动作时，他给该动作分配一个数字（比如订单号），并将其传递给厨师。他还记住了他为每个订单号安排了多少个动作。现在，每当厨师完成他的动作时，他会在销售员身上调用特殊的<code>Reply</code>动作，其中他会传回订单号。然后，销售员会减少此订单剩余的动作数量，如果达到零，他会上菜。</p>
<p>现在你可以说，<code>Reply</code>动作完全没有必要，因为厨师可以在销售员身上安排任何任意的动作，比如<code>Serve</code>，为什么需要特殊的<code>Reply</code>呢？原因是抽象和可重用性。厨师的任务是准备餐点，仅此而已。他没有理由知道自己为什么要准备薯条-它是更大任务的一部分（比如为客户下订单），还是销售员自己饿了。可能不仅销售员有资格叫厨师做餐点-任何餐厅员工都可以只为自己做这样的调用。因此，我们需要一种能够以某种通用方式对演员完成工作作出反应的方式，以便在任何情况下正确处理这种情况。</p>
<p>值得注意的是，<code>Reply</code>可以包含一些附加数据。之前分配的ID是<code>Reply</code>调用中唯一需要的信息，但演员可以传递一些附加数据-发出的<code>events</code>，这些大多是元数据（主要供非区块链应用程序观察），以及任何它想要传递的任意数据。</p>
<h2 id="状态"><a class="header" href="#状态">状态</a></h2>
<p>到目前为止，我们将Actor视为执行某些工作的实体，比如准备餐点。如果我们考虑计算机程序，这样的工作可能是在屏幕上显示某些内容，或者打印一些东西。但智能合约并非如此。智能合约唯一能够影响的是它们的内部状态。因此，状态是合约保存的任意数据。在我之前提到的KFC的例子中，销售员记住了他为厨师安排的尚未完成的动作数量-这个数字是销售员的状态的一部分。</p>
<p>为了给出一个更现实的合约状态的例子，让我们考虑一个比餐厅更贴近现实生活的智能合约。假设我们想要创建自己的货币-也许我们想要为某个MMORPG游戏创建基于智能合约的市场。因此，我们需要某种方式能够至少在玩家之间转移货币。我们可以通过创建一个名为<code>MmoCurrency</code>的合约来实现这一点，该合约支持<code>Transfer</code>动作以将货币转移到其他玩家。那么这样的合约状态是什么呢？它只是一个将玩家名称映射到其所拥有的货币数量的表。我们刚刚提到的合约在CosmWasm示例中是存在的，称为<a href="https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw20-base"><code>cw20-base</code>
合约</a>
（它有些复杂，但这是其核心思想）。</p>
<p>现在有一个问题-如果我无法检查我拥有多少货币，那么如何进行货币转移？这是一个非常好的问题，答案很简单-我们系统中每个合约的整个状态都是公开的。这并非适用于每个Actor模型，但在CosmWasm中，这就是它的工作方式，并且在某种程度上是由区块链的性质所强制的。在区块链上发生的一切都必须是公开的，如果某些信息应该被隐藏，它必须以间接的方式存储。</p>
<p>关于CosmWasm中的状态有一点非常重要，那就是状态是事务性的。对状态的任何更新都不会立即生效，只有当整个操作成功时才会应用。这非常重要，因为它确保如果合约出现问题，它始终保持在某种适当的状态。让我们考虑一下我们的<code>MmoCurrency</code>情况。想象一下，在<code>Transfer</code>动作中，我们首先增加接收者的货币数量（通过更新状态），然后 再减少发送者的数量。然而，在减少之前，我们需要检查发送者是否拥有足够的资金来执行交易。如果我们发现无法执行交易，我们不需要手动进行回滚-我们只需从操作执行中返回一个失败，并且状态不会被更新。因此，当合约状态被更新时，它只是对此状态的局部副本进行修改，而部分更改对其他合约永远不可见。</p>
<h2 id="查询"><a class="header" href="#查询">查询</a></h2>
<p>在CosmWasm对Actor模型的方法中，还有一个构建块我还没有涵盖到。正如我所说，每个合约的整个状态都是公开的，任何人都可以查看。问题是，这种查看状态的方式并不是非常方便-它要求合约的用户了解其内部结构，这在某种程度上违反了SOLID规则（特别是里氏替换原则）。例如，如果一个合约被更新，其状态结构稍作改变，那么查看其状态的另一个合约将永远无法正常工作。此外，合约状态通常是简化的，并且与观察者相关的信息将从状态中计算得出。</p>
<p>这就是查询发挥作用的地方。查询是发送给合约的一种消息类型，它不执行任何动作，因此不更新任何状态，但可以立即返回答案。</p>
<p>在我们的KFC比喻中，查询可以是销售员去问厨师：“我们的芝士汉堡还有酸黄瓜吗？”这可以在运营过程中完成，并且响应可以在其中使用。这是可能的，因为查询永远不会更新其状态，因此它们不需要以事务方式处理。</p>
<p>然而，查询的存在并不意味着我们不能直接查看合约的状态-状态仍然是公开的，直接查看它们的技术被称为“原始查询”（Raw Queries）。为了清楚起见，非原始查询有时被称为“智能查询”（Smart Queries）。</p>
<h2 id="将所有内容综合起来-事务性调用流程"><a class="header" href="#将所有内容综合起来-事务性调用流程">将所有内容综合起来-事务性调用流程</a></h2>
<p>因此，我们在这里涉及了许多内容，我知道这可能有些令人困惑。因此，我想通过对CosmWasm合约进行一些更复杂的调用来形象地说明“事务性状态”意味着什么。</p>
<p>让我们想象两个合约：</p>
<ol>
<li>之前提到的<code>MmoCurrency</code>合约，它可以执行<code>Transfer</code>动作，允许将某个<code>amount</code>的货币转移到某个<code>receiver</code>。</li>
<li><code>WarriorNpc</code>合约，它会拥有一些我们的货币数量，并且会被我们的MMO引擎用于支付玩家完成某个任务的奖励。它将由<code>Payout</code>动作触发，只能由特定的客户（即我们的游戏引擎）调用。</li>
</ol>
<p>现在有一件有趣的事情-这个模型迫使我们在经济方面使我们的MMO更加现实，这是我们通常看到的情况-因为<code>WarriorNpc</code>拥有一些货币，而且无法通过任何方式创造更多。这并非总是如此（之前提到的<code>cw20</code>在这种情况下具有铸币的概念），但为了简单起见，让我们假设这是我们想要的情况。
为了使任务持续更长时间，我们会制定一个奖励，使其始终介于<code>1 mmo</code>和<code>100 mmo</code>之间，但最理想的情况是战士拥有的货币的<code>15%</code>。这意味着随着每位后续玩家的加入，任务奖励会减少，直到战士身无分文，一无所有，无法再支付玩家。</p>
<p>那么，流程会是什么样的？第一个游戏将向<code>WarriorNpc</code>合约发送一个<code>Payout</code>消息，其中包含应该获得奖励的玩家的信息。战士将跟踪完成任务的玩家，以避免重复支付给同一个人-在他的状态中会有一个玩家列表。首先，他会检查列表以查找需要支付的玩家-如果他在列表中，他将以错误结束交易。</p>
<p>然而，在大多数情况下，玩家不会出现在列表中-然后<code>WarriorNpc</code>会将其添加到列表中。现在，战士完成了他的任务，并安排了由<code>MmoCurrency</code>执行的<code>Transfer</code>动作。</p>
<p>但是有一个重要的事情-因为<code>Transfer</code>动作实际上是更大的<code>Payout</code>流程的一部分，它不会在原始的区块链状态上执行，而是在本地副本上执行，该副本已经应用了玩家列表。因此，如果<code>MmoCurrency</code>以任何原因查看<code>WarriorNpc</code>的内部列表，它将已经是更新过的。</p>
<p>现在，<code>MmoCurrency</code>正在执行其工作，更新战士和玩家的余额状态（请注意，我们在这里将我们的战士视为另一个玩家！）。当它完成时，可能会发生两件事：</p>
<ol>
<li>发生错误-可能战士的现金不足，无法再支付任务费用。在这种情况下，对于原始的区块链存储，不会应用任何更改-无论是更新成功玩家列表，还是余额更改。它们就像从未发生过一样。在数据库世界中，这被称为事务回滚。</li>
<li>操作成功-所有对状态的更改现在都已应用到区块链上，任何对<code>MmoCurrency</code>或<code>WarriorNpc</code>的进一步观察都将看到更新后的数据。</li>
</ol>
<p>存在一个问题-在这个模型中，我们的列表不是完成任务的玩家列表（正如我们希望的那样），而是支付奖励的玩家列表（因为在转账失败时，列表不会更新）。我们可以改进。</p>
<h2 id="处理响应的不同方式"><a class="header" href="#处理响应的不同方式">处理响应的不同方式</a></h2>
<p>请注意，我们根本没有提到<code>Reply</code>操作。那么为什么<code>MmoCurrency</code>没有在<code>WarriorNpc</code>上调用它呢？原因是这个操作是可选的。在将子动作安排在另一个合约上时，我们可以选择何时调用<code>Reply</code>以及如何处理结果：</p>
<ol>
<li>从不调用<code>Reply</code>，如果子消息失败，则动作失败。</li>
<li>成功时调用<code>Reply</code>。</li>
<li>失败时调用<code>Reply</code>。</li>
<li>始终调用<code>Reply</code>。</li>
</ol>
<p>因此，如果我们不要求后续合约调用<code>Reply</code>，那么它就不会发生。在这种情况下，如果子调用失败，整个事务将被回滚-子消息的失败会传递导致原始消息失败。现在可能有点复杂，但我保证，如果你能多练习一下，它会变得简单起来。</p>
<p>在处理回复时，重要的是要记住，尽管更改尚未应用到区块链上（事务仍然可能失败），但回复处理程序已经在具有所有子消息迄今为止应用的更改的状态副本上运行。在大多数情况下，这是一件好事，但它有一个棘手的结果-如果合约递归地调用自身，那么后续的调用可能会覆盖原始消息中设置的内容。这种情况很少发生，但在某些情况下可能需要特殊处理-现在我不想深入讨论细节，但我希望你记住在演员的流程中对状态有什么样的期望。</p>
<p>现在让我们来看看如何处理<code>2</code>-<code>4</code>选项的结果。有趣的是，即使使用<code>2</code>，即使子调用成功执行了事务，我们仍然可以查看它通过<code>Reply</code>返回的数据以及它完成后的最终状态，并且我们仍然可以决定将整个操作视为失败，这种情况下一切都会被回滚-甚至是由外部合约执行的货币转移。</p>
<p>在我们的例子中，一个有趣的选项是<code>3</code>。因此，如果合约在失败时调用了<code>Reply</code>，我们可以决定宣称成功，并在子调用失败的情况下提交状态事务。为什么这对我们可能是相关的呢？可能是因为我们的内部列表应该保持完成任务的玩家列表，而不是支付奖励的玩家列表！因此，如果我们没有更多的货币，我们仍然希望更新列表！</p>
<p>使用回复的最常见方式（特别是选项<code>2</code>）是实例化另一个由被调用的合约管理的合约。这种用例的思路是，创建者合约希望将创建的合约地址保留在其状态中。为了做到这一点，它必须创建一个<code>Instantiate</code>子消息，并订阅其成功响应，其中包含新创建的合约的地址。</p>
<p>最后，你可以看到在CosmWasm中执行操作是通过分层状态变更事务来构建的。只有当所有事务都成功时，子事务才能应用到区块链上，但如果子事务失败，只有它的部分会被回滚，而其他更改可能会被应用。这与大多数数据库系统的工作方式非常相似。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>现在，你已经看到了使用Actor模型来避免重入、正确处理错误并安全地隔离合约的强大之处。这有助于我们提供CosmWasm平台的可靠安全保证。现在，让我们开始在<code>wasmd</code>区块链上玩弄真实的合约吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链中的角色"><a class="header" href="#区块链中的角色">区块链中的角色</a></h1>
<p>在之前的讨论中，我们主要从抽象的角度谈论了区块链中的角色。然而，在深入代码之前，我们需要建立一种共同的语言，因此我们将从外部用户的角度来看待智能合约，而不是从实现的角度来看。</p>
<p>在这一部分中，我将使用<code>wasmd</code>二进制文件与马拉加测试网络进行通信。要正确设置，请查看<a href="actor-model/../wasmd-quick-start.html">使用<code>wasmd</code>进行快速入门</a>。</p>
<h2 id="区块链作为数据库"><a class="header" href="#区块链作为数据库">区块链作为数据库</a></h2>
<p>虽然可能有点从终点开始，但我想从角色模型中的状态部分开始。与传统系统相关联，我喜欢将区块链与数据库进行比较。</p>
<p>回顾之前的章节，我们了解到合约的最重要部分是它的状态。通过操作状态，我们可以持久地展示对世界所做的工作。那么，用来保持状态的是什么？它就是数据库！</p>
<p>所以，作为合约开发人员，我认为合约是一个分布式数据库，具有一些神奇的机制使其具有民主性。这些“神奇的机制”对于区块链的存在至关重要，它们是使用区块链的原因，但对于合约创建者而言，它们并不重要-对我们来说，唯一重要的是状态。</p>
<p>但是你可能会问：金融部分呢？区块链（特别是<code>wasmd</code>）不就是货币的实现吗？使用所有这些燃料成本，资金的转移似乎更像是资金转移，而不是数据库更新。是的，你有一定的道理，但我也有解决方案。想象一下，对于每种原生代币（我们指的是直接由区块链处理的代币，与cw20代币相对），有一个特殊的数据库桶（或者如果你愿意，可以称之为表），将地址映射到地址拥有的代币数量。你可以查询这个表（查询代币余额），但不能直接修改它。要对其进行修改，只需向一个特殊的内置银行合约发送消息即可。一切仍然是一个数据库。</p>
<p>但是，如果区块链是一个数据库，那么智能合约存储在哪里呢？显然-它们存储在数据库本身中！现在想象另一个特殊的表-它将包含一个由代码ID映射到Wasm二进制代码块的单个表。同样-要操作此表，您可以使用“特殊合约”，其他合约无法访问该合约，但可以通过<code>wasmd</code>二进制文件使用它</p>
<h2 id="编译合约"><a class="header" href="#编译合约">编译合约</a></h2>
<p>暂时不涉及到具体的代码，但是为了开始，我们需要编译合约的二进制文件。为了简单起见，我们将使用<a href="https://github.com/CosmWasm/cw-plus">cw-plus</a>中的<code>cw4-group</code>合约进行操作。首先，将该仓库克隆到本地：</p>
<pre><code class="language-bash">$ git clone git@github.com:CosmWasm/cw-plus.git
</code></pre>
<p>然后进入<code>cw4-group</code>合约目录并进行构建：</p>
<pre><code class="language-bash">$ cd cw-plus/contracts/cw4-group
$ docker run --rm -v &quot;$(pwd)&quot;:/code \
  --mount type=volume,source=&quot;$(basename &quot;$(pwd)&quot;)_cache&quot;,target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.6
</code></pre>
<p>当合约二进制文件构建完成后，与 CosmWasm 的第一次交互是将其上传到区块链（假设你的 wasm 二进制文件位于工作目录中）：</p>
<pre><code class="language-bash">$ wasmd tx wasm store ./cw4-group.wasm --from wallet $TXFLAG -y -b block
</code></pre>
<p>这样的操作会得到类似以下的 JSON 输出：</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: code_id
      value: &quot;1069&quot;
    type: store_code
</code></pre>
<p>我忽略了大部分不相关的字段，因为目前还不重要 - 我们关心的是区块链发出的包含存储合约的<code>code_id</code>信息的事件 - 在我的情况下，合约代码被存储在区块链上的<code>code_id</code>为<code>1069</code>。现在我可以通过查询来查看代码：</p>
<pre><code class="language-bash">$ wasmd query wasm code 1069 code.wasm
</code></pre>
<p>现在，重要的是要理解合约代码并不是一个 Actor。那么，合约代码是什么？我认为最简单的方式是将其视为编程中的<code>class</code>或<code>type</code>。它定义了一些关于可以执行的操作，但在大多数情况下，该类本身并没有太多用处，除非我们创建该类型的实例，并对其调用类方法。现在让我们继续讨论这种合约类的实例。</p>
<h2 id="合约实例"><a class="header" href="#合约实例">合约实例</a></h2>
<p>现在我们有了合约代码，但我们想要的是一个实际的合约。要创建它，我们需要进行实例化。与编程中的类比类似，实例化是调用构造函数的过程。为了做到这一点，我将发送一个实例化消息给我的合约：</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: []}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
</code></pre>
<p>在这里，我创建了一个新的合约并立即对其调用了<code>Instantiate</code>消息。每个合约代码的消息结构都是不同的。特别是，<code>cw4-group</code>的Instantiate消息包含两个字段：</p>
<ul>
<li><code>members</code>字段，它是初始组成员的列表。</li>
<li>可选的<code>admin</code>字段，它定义了谁可以添加或删除组成员的地址。</li>
</ul>
<p>在这种情况下，我创建了一个没有管理员的空组 - 因此无法更改！这可能看起来像一个不太有用的合约，但它对我们来说作为合约示例很有用。</p>
<p>实例化的结果如下：</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>如您所见，我们再次查看<code>logs[].events[]</code>字段，寻找有趣的事件并从中提取信息 - 这是一种常见情况。我将在未来讨论事件及其属性，但总的来说，事件是通知世界某些事情发生的方式。还记得KFC的例子吗？如果服务员正在为我们送餐，她会在吧台上放置一个托盘，并大声喊出（或在屏幕上显示）订单号 - 这将是宣布事件，因此您知道某个操作的摘要，以便您可以采取一些有用的行动。</p>
<p>那么，我们可以用合约做什么呢？显然，我们可以调用它！但首先，我想告诉您一些有关地址的内容。</p>
<h2 id="cosmwasm中的地址"><a class="header" href="#cosmwasm中的地址">CosmWasm中的地址</a></h2>
<p>在CosmWasm中，地址是指向区块链中实体的一种方式。有两种类型的地址：合约地址和非合约地址。区别在于您可以向合约地址发送消息，因为它们与一些智能合约代码相关联，而非合约地址仅表示系统的用户。在Actor模型中，合约地址表示Actor，非合约地址表示系统的客户端。</p>
<p>在使用<code>wasmd</code>操作区块链时，您也拥有一个地址 - 当您将密钥添加到<code>wasmd</code>时会得到一个地址：</p>
<pre><code class="language-bash"># add wallets for testing
$ wasmd keys add wallet3
- name: wallet3
  type: local
  address: wasm1dk6sq0786m6ayg9kd0ylgugykxe0n6h0ts7d8t
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;Ap5zuScYVRr5Clz7QLzu0CJNTg07+7GdAAh3uwgdig2X&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>你可以随时检查你的地址：</p>
<pre><code class="language-bash">$ wasmd keys show wallet
- name: wallet
  type: local
  address: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;A5bBdhYS/4qouAfLUH9h9+ndRJKvK0co31w4lS4p5cTE&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>拥有一个地址非常重要，因为它是能够调用任何东西的先决条件。当我们向合约发送消息时，合约始终知道发送该消息的地址，因此可以识别它 - 更不用说该发送方是一个会产生燃料费用的地址。</p>
<h2 id="查询合约"><a class="header" href="#查询合约">查询合约</a></h2>
<p>所以，我们有了合约，让我们尝试对其进行一些操作 - 查询可能是最简单的事情。让我们来做一下：</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6 '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p><code>wasm...</code>字符串是合约地址，您必须将其替换为您的合约地址。<code>{ &quot;list_members&quot;: {} }</code>是我们发送给合约的查询消息。通常，CW智能合约的查询采用单个JSON对象的形式，其中包含一个字段：查询名称（在我们的情况下为<code>list_members</code>）。此字段的值是另一个对象，即查询参数 - 如果有的话。<code>list_members</code>查询处理两个参数：<code>limit</code>和<code>start_after</code>，它们都是可选的，并支持结果分页。但是，在我们的空组中，它们并不重要。</p>
<p>我们得到的查询结果以人类可读的文本形式呈现（如果我们想要获取JSON形式的结果 - 例如，为了进一步使用<code>jq</code>进行处理，只需传递<code>-o json</code>标志）。如您所见，响应包含一个字段：<code>members</code>，它是一个空数组。</p>
<p>那么，我们能否对这个合约做更多的事情？并不多。但是让我们尝试使用一个新合约做一些操作！</p>
<h2 id="执行以执行一些操作"><a class="header" href="#执行以执行一些操作">执行以执行一些操作</a></h2>
<p>我们之前的合约的问题在于，对于<code>cw4-group</code>合约，唯一可以执行操作的人是管理员，但我们的合约没有管理员。虽然这并不适用于每个智能合约，但它是这个合约的特性。</p>
<p>因此，让我们创建一个新的组合约，但这次我们将自己设置为管理员。首先，请检查我们的钱包地址：</p>
<pre><code class="language-bash">$ wasmd keys show wallet
</code></pre>
<p>实例化一个新的组合约 - 这次使用正确的管理员：</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: [], &quot;admin&quot;: &quot;wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx&quot;}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
..
logs:
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>您可能会问，为什么我们要传递某种<code>--no-admin</code>标志，如果我们刚刚说过，我们要将一个管理员设置给合约？答案令人沮丧和困惑，但是...这是一个不同的管理员。我们想要设置的管理员是由合约本身检查并管理的管理员。而通过<code>--no-admin</code>标志拒绝的管理员是wasmd级别的管理员，可以迁移合约。至少在您学习有关合约迁移之前，您不需要担心第二个管理员 - 在那之前，您可以始终向合约传递<code>--no-admin</code>标志。</p>
<p>现在让我们查询我们的新合约的成员列表：</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p>就像以前一样 - 最初没有成员。现在检查管理员：</p>
<pre><code>$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;admin&quot;: {} }'
data:
  admin: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
</code></pre>
<p>所以，有一个管理员，看起来像我们想要的那个。现在我们会添加某人到这个组中 - 也许是我们自己？</p>
<pre><code class="language-bash">wasmd tx wasm execute wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;update_members&quot;: { &quot;add&quot;: [{ &quot;addr&quot;: &quot;wasm1um59mldkdj8ayl5gkn
p9pnrdlw33v40sh5l4nx&quot;, &quot;weight&quot;: 1 }], &quot;remove&quot;: [] } }' --from wallet $TXFLAG -y
</code></pre>
<p>修改成员的消息是<code>update_members</code>，它有两个字段：要删除的成员和要添加的成员。要删除的成员只是地址。要添加的成员具有更复杂的结构：它们是带有两个字段的记录：地址和权重。权重对我们来说并不重要，它只是与每个组成员一起存储的元数据 - 对于我们来说，它始终为1。</p>
<p>让我们再次查询合约，检查我们的消息是否有任何更改：</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members:
  - addr: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
    weight: 1
</code></pre>
<p>正如您所见，合约已更新其状态。基本上就是这样运作的 - 向合约发送消息会导致它们更新状态，并且可以随时查询状态。为了保持简单，我们现在只是直接通过<code>wasmd</code>与合约进行交互，但正如前面所描述的 - 合约可以相互通信。然而，要调查这一点，我们需要了解如何编写合约。下次我们将查看合约结构，并将其逐部分映射到我们到目前为止学到的内容中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能合约作为一个角色"><a class="header" href="#智能合约作为一个角色">智能合约作为一个角色</a></h1>
<p>在之前的章节中，我们讨论了角色模型及其在区块链中的实现方式。现在是时候更详细地了解典型合约结构，以理解如何将角色模型的不同特性映射到其中。</p>
<p>这不是一个逐步创建合约的指南，因为这是系列的主题。我们将大致浏览合约元素，以便形象化地了解如何处理角色模型中的架构。</p>
<h2 id="状态-1"><a class="header" href="#状态-1">状态</a></h2>
<p>与之前一样，我们将从状态开始。之前我们使用了 <code>cw4-group</code> 合约，所以让我们从查看其代码开始。进入 <code>cw-plus/contracts/cw4-group/src</code> 文件夹。文件夹结构应如下所示：</p>
<pre><code class="language-bash">📁src
├── 📃contract.rs
├── 📃error.rs
├── 📃helpers.rs
├── 📃lib.rs
├── 📃msg.rs
└── 📃state.rs
</code></pre>
<h2 id="智能合约作为角色"><a class="header" href="#智能合约作为角色">智能合约作为角色</a></h2>
<p>在之前的章节中，我们讨论了角色模型以及如何在区块链中实现它。现在是时候更详细地了解典型合约结构，以理解角色模型的不同特征如何映射到合约中。</p>
<p>这不是一个逐步创建合约的指南，因为这是本系列的主题。我们将大致浏览合约元素，以便形象化地了解如何在角色模型中处理架构。</p>
<h2 id="状态-2"><a class="header" href="#状态-2">状态</a></h2>
<p>如你所见，我们首先要查看的是 <code>state.rs</code>。</p>
<p>这里最重要的是几个常量：<code>ADMIN</code>、<code>HOOKS</code>、<code>TOTAL</code> 和 <code>MEMBERS</code>。每个常量代表合约状态的一个部分，就像数据库中的表一样。这些常量的类型表示了该表的类型。最基本的类型是 <code>Item&lt;T&gt;</code>，它保存一个给定类型的零个或一个元素，以及 <code>Map&lt;K, T&gt;</code>，它是一个键值映射。</p>
<p>你可以看到，<code>Item</code> 用于保存管理员和其他一些数据：<code>HOOKS</code> 和 <code>TOTAL</code>。<code>HOOKS</code> 由 <code>cw4-group</code> 用于允许订阅对群组的任何更改 - 合约可以作为钩子添加，因此当群组发生更改时，会发送一条消息。<code>TOTAL</code> 只是所有成员权重的总和。</p>
<p><code>MEMBERS</code> 在群组合约中是 <code>SnapshotMap</code> - 正如你所想象的，它是一个 <code>Map</code>，带有一些增强功能 - 这个特殊的 <code>Map</code> 可以让我们通过区块链的 <code>height</code> 访问到某个历史时刻的映射状态。<code>height</code> 是自区块链开始以来创建的块的数量，它是智能合约中最原子的时间表示。在智能合约中，有一种方式可以访问当前的时钟时间，但在同一个区块中发生的所有操作都被认为是在同一时刻发生的。</p>
<p>其他未在群组合约中使用的存储对象类型有：</p>
<ul>
<li><code>IndexedMap</code> - 另一种键值映射类型，允许通过多种键访问值</li>
<li><code>IndexedSnapshotMap</code> - <code>IndexedMap</code> 和 <code>SnapshotMap</code> 的结合体</li>
</ul>
<p>非常重要的一点是，合约中的每个状态类型都是通过名称进行访问的。所有这些类型都不是容器，只是访问状态的访问器。还记得我之前告诉过你，区块链是我们的数据库吗？是的，没错！所有这些类型只是我们访问该数据库的对象关系映射（ORM）- 当我们使用它们从数据库中获取实际数据时，我们向它们传递一个特殊的 <code>State</code> 对象，以便它们可以从中检索项目。</p>
<p>你可能会问 - 为什么合约的所有这些数据不是由运行合约的任何东西自动获取的呢？这是个好问题。原因是我们希望合约在获取数据时是延迟的。复制数据是一项非常昂贵的操作，对于发生在合约上的每一件事，都有人需要付费 - 这是通过燃气成本来实现的。我之前告诉过你，作为合约开发者，你完全不需要担心燃气成本，但这只是部分正确。你不需要确切地知道燃气是如何计算的，但通过降低你的燃气成本，你可能会使合约的执行更便宜，而这通常是一件好事。一个好的实践方法是避免获取在特定调用中不会使用的数据。</p>
<h2 id="消息"><a class="header" href="#消息">消息</a></h2>
<p>在区块链中，合约通过一些 JSON 消息进行通信。它们在大多数合约中定义在 <code>msg.rs</code> 文件中。让我们来看一下。</p>
<p>这里有三种类型，我们逐一进行介绍。
第一种是 <code>InstantiateMsg</code>。这是在实例化合约时发送的消息。通常它包含一些数据，用于正确初始化合约。在大多数情况下，它只是一个简单的结构体。</p>
<p>然后，还有两个枚举类型：<code>ExecuteMsg</code> 和 <code>QueryMsg</code>。它们是枚举类型，因为它们的每个变体表示可以发送的不同消息。例如，<code>ExecuteMsg::UpdateAdmin</code> 对应于我们之前发送的 <code>update_admin</code> 消息。</p>
<p>请注意，所有的消息都带有 <code>#[derive(Serialize, Deserialize)]</code> 和 <code>#[serde(rename_all=&quot;snake_case&quot;)]</code> 属性。这些属性来自于 <a href="https://serde.rs/">serde</a> crate，它们帮助我们对它们进行反序列化（以及在发送到其他合约时的序列化）。第二个属性并不是必需的，但它允许我们在 Rust 代码中保持驼峰命名风格，并且仍然以更符合 JSON 规范的蛇形命名风格进行编码。</p>
<p>我鼓励你更详细地查阅 <code>serde</code> 文档，因为其中的所有内容都可以与消息一起使用。</p>
<p>值得注意的一点是，这些消息类型并不是固定的，它们可以是任何类型。这只是一个约定，但有时你会看到类似于 <code>ExecuteCw4Msg</code> 的东西。只要记住，保持消息名称在目的上明确 - 遵循 <code>ExecuteMsg</code>/<code>QueryMsg</code> 是一个好主意。</p>
<h2 id="入口点-1"><a class="header" href="#入口点-1">入口点</a></h2>
<p>现在，当我们有了合约消息，我们需要一种处理它们的方式。它们通过入口点发送到我们的合约。<code>cw4-group</code> 合约中有三个入口点：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    // ..
}
<span class="boring">}</span></code></pre></pre>
<p>那些函数是由 CosmWasm 虚拟机在合约处理消息时调用的。你可以将它们视为普通程序的 <code>main</code> 函数，只是它们具有更好描述区块链本身的签名。</p>
<p>非常重要的一点是，这些入口点的名称（类似于 <code>main</code> 函数）是固定的 - 这很重要，以便虚拟机知道要调用什么。</p>
<p>因此，让我们从第一行开始。每个入口点都带有 <code>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]</code> 属性。这可能看起来有点可怕，但它只是 <code>#[entry_point]</code> 的条件等效 - 该属性仅在没有设置 &quot;library&quot; 特性时存在。我们这样做是为了能够将我们的合约用作其他合约的依赖项 - 最终的二进制文件中只能包含每个入口点的一个副本，因此我们确保只有顶层入口点在没有此特性的情况下编译。</p>
<p><code>entry_point</code> 属性是一个宏，生成了一些样板代码。由于二进制文件由 WASM 虚拟机运行，它对 Rust 类型了解不多 - 实际的入口点签名非常不方便使用。为了解决这个问题，创建了一个宏，为我们生成了入口点，而这些入口点只是调用我们的函数。</p>
<p>现在看看函数参数。每个入口点的最后一个参数都是触发其执行的消息（除了 <code>reply</code> - 我稍后会解释它）。除此之外，区块链还提供了其他一些参数：</p>
<ul>
<li><code>Deps</code> 或 <code>DepsMut</code> 对象是与智能合约上下文之外世界的接口。它允许访问合约状态，查询其他合约，并提供了一个带有一些有用的实用函数的 <code>Api</code> 对象。区别在于 <code>DepsMut</code> 允许更新状态，而 <code>Deps</code> 仅允许查看状态。</li>
<li><code>Env</code> 对象提供执行时区块链状态的信息 - 它的高度、执行的时间戳以及有关执行合约本身的信息。</li>
<li><code>MessageInfo</code> 对象是关于合约调用的信息 - 它包含发送消息的地址以及随消息发送的资金。</li>
</ul>
<p>请记住，这些函数的签名是固定的（除了消息类型），所以在查询调用中不能将 <code>Deps</code> 替换为 <code>DepsMut</code> 以更新合约状态。</p>
<p>入口点的最后部分是返回类型。每个入口点都返回一个 <code>Result</code> 类型，其中包含可以转换为字符串的任何错误 - 在合约失败的情况下，返回的错误仅被记录。在大多数情况下，错误类型为合约本身定义，通常使用 <a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> crate 定义。这里不需要 <code>Thiserror</code>，但强烈建议使用它 - 使用它可以使错误定义非常直观，并提高合约的可测试性。</p>
<p>重要的是 <code>Result</code> 的 <code>Ok</code> 部分。让我们从查询开始，因为这是最简单的部分。查询总是返回 <code>Ok</code> 情况下的 <code>Binary</code> 对象，其中只包含序列化的响应。创建它的常见方法只是在实现了 <code>serde::Serialize</code> 的对象上调用 <code>to_binary</code> 方法，它们通常在 <code>msg.rs</code> 中定义，紧邻消息类型。</p>
<p>其他入口点返回的类型稍微复杂一些 - <code>cosmwasm_std::Response</code> 类型。它保存了完成合约执行所需的所有信息。该类型的信息分为三个部分。</p>
<p>第一部分是 <code>events</code> 字段。它包含作为执行结果而向区块链发出的所有事件。事件的结构非常简单：它们有一个类型，即一个字符串，以及一组属性，即字符串-字符串键值对。</p>
<p>你可能注意到了 <code>Response</code> 上还有一个 <code>attributes</code> 字段。这只是为了方便起见 - 大多数执行只会返回一个事件，为了更容易处理，响应上直接有一组属性。所有这些属性都将转换为一个 <code>wasm</code> 事件，然后发出。因此，我认为 <code>events</code> 和 <code>attributes</code> 是同一组数据。</p>
<p>然后我们有 <code>messages</code> 字段，类型为 <code>SubMsg</code>。这是交叉合约通信的关键。这些消息在处理完成后会被发送到其他合约。重要的是，除非合约发送的所有子消息也被处理（即使它们失败），否则整个执行不会完成。因此，如果组合合约发送了一些消息作为 <code>update_members</code> 执行的结果，只有在处理由它发送的所有消息后，执行才会被认为完成（即使它们失败）。</p>
<p>因此，当合约发送的所有子消息都被处理完毕后，所有子调用和顶层调用生成的所有属性都会被收集并报告给区块链。但还有一个额外的信息 - <code>data</code>。这是另一个 <code>Binary</code> 字段，与查询调用的结果完全相同，通常包含序列化的 JSON。每个合约调用都可以返回一些额外的信息，以任何格式。你可能会问 - 在这种情况下，我们为什么还要返回属性？这是因为事件和数据发出的方式完全不同。由合约发出的任何属性最终都将在区块链上可见（除非整个消息处理失败）。但对于数据来说，情况就不同了。每个合约调用只会返回单个 <code>data</code> 块，它必须决定是仅转发一个子调用的 <code>data</code> 字段，还是可能自己构造一些内容。稍后我会更详细地解释。</p>
<h2 id="发送子消息"><a class="header" href="#发送子消息">发送子消息</a></h2>
<p>我不想详细介绍 <code>Response</code> API，因为它可以直接从文档中阅读，但我想更详细地介绍一下发送消息的部分。</p>
<p>首先要使用的函数是 <code>add_message</code>，它接受 <code>CosmosMsg</code>（或可以转换为 <code>CosmosMsg</code> 的任何内容）作为参数。通过这种方式添加到响应中的消息将被发送和处理，但其执行不会对合约的结果产生影响。</p>
<p>另一个要使用的函数是 <code>add_submessage</code>，它接受一个 <code>SubMsg</code> 参数。它与 <code>add_message</code> 的区别不大 - <code>SubMsg</code> 只是在 <code>CosmosMsg</code> 上添加了一些信息：<code>id</code> 字段和 <code>reply_on</code> 字段。还有一个 <code>gas_limit</code> 字段，但它并不重要 - 它只会在达到燃气阈值时使子消息处理提前失败。</p>
<p>简单的是 <code>reply_on</code> - 它描述了是否应在处理成功、处理失败或两者都发送 <code>reply</code> 消息。</p>
<p><code>id</code> 字段是我们在一开始的 KFC 示例中所说的订单号的等效物。如果您发送多个不同的子消息，如果没有该字段，将无法区分它们。甚至无法确定原始消息回复处理的类型！这就是 <code>id</code> 字段存在的原因 - 发送子消息时，可以将其设置为任何值，然后在回复时，可以根据该字段确定发生了什么。</p>
<p>一个重要的注意事项 - 您无需担心生成复杂的 id。记住，整个处理过程是原子的，一次只能进行一个执行。在大多数情况下，您的合约会在非常具体的执行中发送固定数量的子消息。因此，您可以在发送时硬编码大多数这些 id（最好使用一些常量）。</p>
<p>为了更轻松地创建子消息，您通常会使用帮助函数构造函数：<code>SubMsg::reply_on_success</code>、<code>SubMsg::reply_on_error</code> 和 <code>SubMsg::reply_always</code>。</p>
<h2 id="cosmosmsg"><a class="header" href="#cosmosmsg">CosmosMsg</a></h2>
<p>如果您查看了 <code>CosmosMsg</code> 类型，您可能会感到非常惊讶 - 它们有这么多的变体，而且并不明显它们与其他合约的通信如何相关。</p>
<p>您要查找的消息是 <code>WasmMsg</code>（<code>CosmosMsg::Wasm</code> 变体）。这个消息与我们已经了解的内容非常相似 - 它具有一些操作的变体，用于合约执行：<code>Execute</code>，还有 <code>Instantiate</code>（因此我们可以在合约执行中创建新的合约），以及 <code>Migrate</code>、<code>UpdateAdmin</code> 和 <code>ClearAdmin</code> - 这些用于管理迁移（我将在本章末尾稍微介绍一下）。</p>
<p>另一个有趣的消息是 <code>BankMsg</code>（<code>CosmosMsg::Bank</code>）。它允许合约将本地代币转移到其他合约（或销毁它们 - 相当于将它们转移到某个黑洞合约）。我喜欢将其视为向一个非常特殊的合约发送消息，该合约负责处理本地代币 - 这不是真正的合约，因为它由区块链本身处理，但至少对我来说，这简化了事情。</p>
<p><code>CosmosMsg</code> 的其他变体现在不是很有趣。<code>Custom</code> 是为了允许其他基于 CosmWasm 的区块链添加一些区块链处理的消息变体。这就是为什么大多数与消息相关的类型在 CosmWasm 中是针对某个 <code>T</code> 的通用类型的原因 - 这只是一种特定于区块链的消息类型。我们在 <code>wasmd</code> 中永远不会使用它。其他的消息变体与高级的 CosmWasm 功能有关，我在这里不会详细介绍。</p>
<h2 id="回复处理"><a class="header" href="#回复处理">回复处理</a></h2>
<p>既然我们知道如何发送子消息，现在是时候谈论一下如何处理回复了。当子消息处理完成并请求回复时，合约会通过入口点进行调用：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn reply(deps: DepsMut, env: Env, msg: Reply) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>DepsMut</code>和<code>Env</code>参数已经很熟悉了，但是现在有一个新的参数，替代了典型的消息参数：<code>cosmwasm_std::Reply</code>。</p>
<p>这是一种表示子消息执行状态的类型。它是经过轻微处理的<code>cosmwasm_std::Response</code>。它包含的第一个重要信息是一个<code>id</code>，这个<code>id</code>与发送子消息时设置的相同，因此现在你可以识别你的响应。另一个重要信息是<code>ContractResult</code>，它与Rust的<code>Result&lt;T, String&gt;</code>类型非常相似，但是它用于序列化目的。你可以使用<code>into_result</code>函数将其轻松转换为<code>Result</code>类型。</p>
<p>在<code>ContractResult</code>的错误情况下，有一个字符串 - 正如我之前提到的，错误在执行后会转换为字符串。<code>Ok</code>情况下包含一个<code>SubMsgExecutionResponse</code>，它有两个字段：子调用发出的事件<code>events</code>和嵌入在响应中的<code>data</code>字段。
正如之前所说，你不需要担心事件的转发 - CosmWasm会自动处理。然而，<code>data</code>就是另外一回事了。正如前面提到的，每次调用只会返回一个<code>data</code>对象。在发送子消息并且不捕获回复的情况下，<code>data</code>将始终是顶层消息返回的内容。但是当调用<code>reply</code>时情况就不同了。如果调用了<code>reply</code>，那么它将决定最终的<code>data</code>。它可以选择要么转发子消息的数据（通过返回<code>None</code>），要么覆盖它。它不能选择返回原始执行处理的数据 - 如果合约发送了等待回复的子消息，它应该不返回任何数据，除非调用了回复。</p>
<p>但是如果发送了多个子消息会发生什么？最终的<code>data</code>会包含什么？规则是 - 最后一个非<code>None</code>值。所有的子消息总是按照添加到<code>Response</code>中的顺序调用。由于顺序是确定性和明确定义的，因此始终可以轻松预测将使用哪个回复。</p>
<h2 id="迁移"><a class="header" href="#迁移">迁移</a></h2>
<p>在前面描述<code>WasmMsg</code>时，我提到了迁移。所以，迁移是合约可以执行的另一个操作，有点类似于实例化。在软件工程中，发布应用程序的更新版本是常见的事情。在区块链中也是如此 - 智能合约可以通过一些新功能进行更新。在这种情况下，会上传新的代码，并迁移合约 - 这样它就知道从这一点开始，它的消息将由另一个更新的合约代码处理。</p>
<p>然而，可能存在合约状态在旧版本和新版本中存在差异的情况。如果添加了一些信息（例如一些额外的映射 - 在迁移后它将是空的），这并不是问题。但问题是当状态发生变化时，例如字段被重命名。在这种情况下，由于（反）序列化问题，每次合约执行都会失败。或者更加微妙的情况，例如添加映射，但这个映射应该与整个合约状态同步，而不是为空。</p>
<p>这就是<code>migration</code>入口点的目的。它的样子如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -&gt; Result&lt;Response&lt;T&gt;, ContracError&gt; {
    // ..
}
<span class="boring">}</span></code></pre></pre>
<p><code>MigrateMsg</code>是在<code>msg.rs</code>中由合约定义的类型。
<code>migrate</code>入口点将在执行迁移时调用，它负责确保迁移后状态正确。它与传统数据库应用程序中的模式迁移非常相似。由于涉及版本管理，这也有点困难 - 您永远不能假设您正在从前一个版本迁移合约 - 它可以从任何版本迁移，任何时间发布 - 甚至晚于我们要迁移到的版本！</p>
<p>值得回顾一下过去的一个问题 - 合约管理员。还记得我们之前在每个合约实例化时设置的 <code>--no-admin</code> 标志吗？这使得我们的合约无法进行迁移。只有合约管理员才能执行迁移。要使用迁移功能，您应该使用 <code>--admin address</code> 标志，其中 <code>address</code> 是能够执行迁移的地址。</p>
<h2 id="sudo"><a class="header" href="#sudo">Sudo</a></h2>
<p>Sudo是<code>CosmWasm</code>中最后一个基本的入口点，在<code>wasmd</code>中我们永远不会使用它。它等效于 <code>CosmosMsg::Custom</code>，但是它不是由区块链自身发送和处理的特殊区块链特定消息，而是由区块链在某些情况下发送给合约的特殊区块链特定消息。这些消息有很多用途，但我不会涉及它们，因为它们与<code>CosmWasm</code>本身无关。<code>sudo</code>的签名如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
<span class="boring">}</span></code></pre></pre>
<p>重要的区别是，由于<code>sudo</code>消息是特定于区块链的，因此<code>SudoMsg</code>类型通常由某个区块链辅助工具crate定义，而不是合约本身定义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="跨合约通信"><a class="header" href="#跨合约通信">跨合约通信</a></h1>
<p>我们已经介绍了如何创建一个单一隔离的合约。然而，SOLID 原则告诉我们，实体应该尽可能小，即具有<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">单一责任</a>。我们现在关注的实体是智能合约，我们希望确保每个智能合约都有它负责的唯一责任。</p>
<p>但是我们也希望使用智能合约构建复杂系统。为了做到这一点，我们需要能够在它们之间进行通信。我们已经讨论了使用 Actor 模型进行通信的方式。现在是时候将这些知识应用于实践了。</p>
<p>在本章中，我们将改进之前创建的管理组模型，以解决我提出的问题 - 单个管理员可以添加自己的多个地址以获取更大的捐赠份额。</p>
<p>此外，我们还将给管理员一些工作以外的任务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计"><a class="header" href="#设计">设计</a></h1>
<p>这一次我们将讨论系统的设计。构建多合约系统往往比单独的合约复杂一些，所以我想给你一些关于本章构建内容的指引。如果你在设计上感到迷失，不用担心 - 在实施合约时一切都会变得清晰起来。现在，先浏览一遍以获得一个大致的了解。</p>
<p>首先，让我们思考一下我们要解决的问题。我们的管理员是一个地址向量。任何已经是管理员的人都可以将其他人添加到列表中。但是这个“其他人”可能是同一个管理员账户的第二个实例，这样他的捐赠计数就会算两次！</p>
<p>这个问题相对比较简单修复，但还有另一个问题 - 正如我们已经了解的，管理员可以创建一个只有他自己可以从中提取代币并注册为组中的另一个管理员的智能合约！通过多次实例化，即使我们阻止了多次添加相同地址，他仍然可以达到他的目标。同一个人可能拥有多个不同的地址。</p>
<p>这看起来是一个令人不愉快的情况，但有办法来管理它。我们将要实现的方法是投票。管理员不再能够直接将另一个管理员添加到列表中，而是可以提议他们的同事成为新的管理员。这将启动一个投票过程 - 在提议创建时已经是管理员的每个人都可以支持它。如果超过半数的管理员支持新的候选人，他将立即成为管理员。</p>
<p>这并不是最复杂的投票过程，但对于我们的目的已经足够了。</p>
<h2 id="投票过程"><a class="header" href="#投票过程">投票过程</a></h2>
<p>为了实现这个目标，我们将创建两个智能合约。首先，我们将重用 <a href="cross-contract/../basics.html">基础知识</a> 章节中的一个合约 - 它将是一个 <code>admin</code> 合约。另外，我们将添加一个 <code>voting</code> 合约。它将负责管理单个投票过程。每当管理员想要将他的朋友添加到列表中时，它将由 <code>admin</code> 合约实例化。下面是合约之间关系的示意图：</p>
<p><img src="cross-contract/../mdbook-plantuml-img/66f4c7e9766997a755cbf3507f13144b5787e5da.svg" alt="" /></p>
<p>这里是添加管理员流程图 - 假设合同上已经有5个管理员，但其中2个什么也没做：</p>
<p><img src="cross-contract/../mdbook-plantuml-img/6528660a9f88cc401fb1b6e62181485b144687ae.svg" alt="" /></p>
<p>我已经提供了一些关于合同实施的提示，但我暂时不会深入讨论它们。</p>
<h2 id="消息转发"><a class="header" href="#消息转发">消息转发</a></h2>
<p>我们还想添加一件事情 - 提供给管理员一种工作方式。<code>admin</code>合约将充当调用另一个合约的代理。这意味着其他外部合约将仅将我们的<code>admin</code>实例设置为可以对其执行操作的特定地址，管理员将通过这种方式执行操作。外部合约将以<code>admin</code>合约执行的方式执行操作。下面是更新后的合约图示：</p>
<p><img src="cross-contract/../mdbook-plantuml-img/5ea499d765387fa9c0342773a37395cb916614ef.svg" alt="" /></p>
<p>调用外部合约流程图：</p>
<p><img src="cross-contract/../mdbook-plantuml-img/071046fb2dd72667d935d09a8cb4c0c5108e8ee3.svg" alt="" /></p>
<p>请注意，在<code>execute</code>管理员合约消息中的<code>msg</code>是一个随意转发给外部合约的消息。在现实世界中，它将是一个Base64编码的消息，但这只是一个实现细节。</p>
<p>最终，我们将创建一个简单的外部合约示例，以了解如何使用这种模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="修复管理员合约"><a class="header" href="#修复管理员合约">修复管理员合约</a></h1>
<p>现在我们知道了我们想要实现的目标，我们可以开始对已有的合约进行调整，使其成为管理员合约。目前它基本上还可以，但我们想要进行一些清理。</p>
<h2 id="清理查询"><a class="header" href="#清理查询">清理查询</a></h2>
<p>首先要做的是删除<code>Greet</code>查询-它作为一个起始查询示例很好，但没有实际用途，只会产生噪音。</p>
<p>我们想要从查询枚举中删除不必要的变体：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_schema::{cw_serde, QueryResponses};
</span><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">    pub donation_denom: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub enum ExecuteMsg {
</span><span class="boring">    Leave {},
</span><span class="boring">    Donate {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(AdminsListResp)]
    AdminsList {},
}
<span class="boring">}</span></code></pre></pre>
<p>然后我们还会在查询调度程序中删除无效路径：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>最后，我们从<code>contract::query</code>模块中移除了不相关的处理程序。我们还需要确保所有对它的引用都消失了（例如，如果在测试中有任何引用）。</p>
<h2 id="生成库文件输出"><a class="header" href="#生成库文件输出">生成库文件输出</a></h2>
<p>在本书的开头，我们将<code>Cargo.toml</code>中的<code>crate-type</code>设置为<code>&quot;cdylib&quot;</code>。这是为了生成wasm输出所必需的，但它有一个缺点-动态库不能用作其他crate的依赖项。在此之前，这不是一个问题，但在实践中，我们经常希望将合约依赖于其他合约，以便获得对它们的某些类型的访问权限-例如，定义的消息。</p>
<p>对我们来说，修复这个问题很容易。您可能会注意到<code>crate-type</code>是一个数组，而不是一个单独的字符串。这是因为我们的项目可以生成多个目标-特别是，我们可以在其中添加默认的<code>&quot;rlib&quot;</code>crate类型，以生成“rust库”输出-这正是我们需要作为依赖项使用的。让我们更新我们的<code>Cargo.toml</code>文件：</p>
<pre><code class="language-toml">[package]
name = &quot;admin&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
# 
# [features]
# library = []
# 
# [dependencies]
# cosmwasm-std = { version = &quot;1.1.4&quot;, features = [&quot;staking&quot;] }
# serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
# cw-storage-plus = &quot;0.15.1&quot;
# thiserror = &quot;1&quot;
# schemars = &quot;0.8.1&quot;
# cw-utils = &quot;0.15.1&quot;
# cosmwasm-schema = &quot;1.1.4&quot;
# 
# [dev-dependencies]
# cw-multi-test = &quot;0.15.1&quot;
</code></pre>
<p>此外，请注意我更改了合约的名称 - &quot;contract&quot;不太具有描述性，所以我将其更新为&quot;admin&quot;。</p>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<p>最后但并非最不重要的是 - 我们希望更好地组织我们的项目结构。到目前为止，我们只有一个合约，所以我们将其作为整个项目来处理。现在我们希望有一个反映我们创建的合约之间关系的目录树。</p>
<p>首先，在项目中创建一个目录。然后我们想在其中创建一个名为&quot;contracts&quot;的子目录。从Rust的角度来看，这在技术上并不是必需的，但在我们的环境中有一些工具（例如工作区优化器），它们会假设它是应该查找合约的位置。这是您在CosmWasm合约存储库中常见的模式。</p>
<p>然后，我们将上一章中的整个项目目录复制到&quot;contracts&quot;目录中，并将其重命名为&quot;admin&quot;。</p>
<p>最后，我们希望将所有项目（目前只有一个，但我们知道以后会有更多）耦合在一起。为此，在顶层项目目录中创建工作区级别的<code>Cargo.toml</code>文件：</p>
<pre><code class="language-toml">[workspace]
members = [&quot;contracts/*&quot;]
resolver = &quot;2&quot;
</code></pre>
<p>这个<code>Cargo.toml</code>与典型的项目级<code>Cargo.toml</code>略有不同 - 它定义了工作区。这里最重要的字段是<code>members</code> - 它定义了作为工作区一部分的项目。</p>
<p>另一个字段是<code>resolver</code>。记住要添加它 - 它指示Cargo使用依赖解析器的第2版。自Rust 2021以来，这已经是非工作区的默认设置，但由于兼容性原因，默认设置无法更改为工作区 - 但建议在每个新创建的工作区中添加它。</p>
<p>最后一个可能对工作区有用的字段是<code>exclude</code> - 它允许在工作区目录树中创建不属于该工作区的项目 - 我们不会使用它，但了解它是很好的。</p>
<p>现在只是为了清晰起见，让我们来看看顶层目录结构：</p>
<pre><code class="language-none">.
├── Cargo.lock
├── Cargo.toml
├── contracts
│  └── admin
└── target
   ├── CACHEDIR.TAG
   └── debug
</code></pre>
<p>你可以看到目录树中存在目标目录和<code>Cargo.lock</code>文件 - 这是因为我已经为<code>admin</code>合约构建并运行了测试 - 在Rust工作区中，<code>cargo</code>知道要在顶层构建所有内容，即使是从内部目录构建也是如此。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="映射存储"><a class="header" href="#映射存储">映射存储</a></h1>
<p>管理员合约中有一个需要立即改进的地方，那就是检查合约的状态：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use cw_storage_plus::Item;
</span><span class="boring">
</span>pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}</span></code></pre></pre>
<p>请注意，我们将管理员列表保存为一个向量（vector）。然而，在整个合约中，大多数情况下，我们只访问该向量的单个元素。</p>
<p>这并不理想，因为现在，每当我们想要访问单个管理员条目时，我们首先必须对包含所有管理员的列表进行反序列化，然后对它们进行迭代，直到找到感兴趣的条目。这可能会消耗大量的计算资源，并且是完全不必要的开销 - 我们可以使用 <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html">Map</a> 存储访问器来避免这种情况。</p>
<h2 id="map-存储"><a class="header" href="#map-存储"><code>Map</code> 存储</a></h2>
<p>首先，让我们定义一个 Map - 在这个上下文中，它将是一组具有分配给它们的值的键，就像 Rust 中的 <code>HashMap</code> 或许多其他语言中的字典一样。我们将其定义为类似于 <code>Item</code>，但这次我们需要两种类型 - 键类型和值类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cw_storage_plus::Map;

pub const STR_TO_INT_MAP: Map&lt;String, u64&gt; = Map::new(&quot;str_to_int_map&quot;);
<span class="boring">}</span></code></pre></pre>
<p>要在<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html"><code>Map</code></a>上存储一些项，我们使用<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.save"><code>save</code></a>方法 - 与<code>Item</code>相同：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>STR_TO_INT_MAP.save(deps.storage, &quot;ten&quot;.to_owned(), 10);
STR_TO_INT_MAP.save(deps.storage, &quot;one&quot;.to_owned(), 1);
<span class="boring">}</span></code></pre></pre>
<p>访问Map中的条目与读取项一样简单：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten = STR_TO_INT_MAP.load(deps.storage, &quot;ten&quot;.to_owned())?;
assert_eq!(ten, 10);

let two = STR_TO_INT_MAP.may_load(deps.storage, &quot;two&quot;.to_owned())?;
assert_eq!(two, None);
<span class="boring">}</span></code></pre></pre>
<p>显然，如果在Map中缺少元素，<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.load"><code>load</code></a> 函数将会导致错误，就像对于项一样。另一方面，<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.may_load"><code>may_load</code></a> 在元素存在时返回 <code>Some</code> 变体。</p>
<p>另一个对Map特定的非常有用的访问器是 <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.has"><code>has</code></a> 函数，它检查Map中是否存在指定的键：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contains = STR_TO_INT_MAP.has(deps.storage, &quot;three&quot;.to_owned())?;
assert!(!contains);
<span class="boring">}</span></code></pre></pre>
<p>最后，我们可以遍历Map的元素 - 无论是键还是键值对：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::Order;

for k in STR_TO_INT_MAP.keys(deps.storage, None, None, Order::Ascending) {
    let _addr = deps.api.addr_validate(k?);
}

for item in STR_TO_INT_MAP.range(deps.storage, None, None, Order::Ascending) {
    let (_key, _value) = item?;
}
<span class="boring">}</span></code></pre></pre>
<p>首先，你可能会想到传递给 <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.keys"><code>keys</code></a> 和 <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.range"><code>range</code></a> 的额外值 - 这些值是按顺序排列的：迭代元素的下限和上限，以及元素的遍历顺序。</p>
<p>在使用典型的 Rust 迭代器时，你可能会首先创建一个包含所有元素的迭代器，然后以某种方式跳过你不感兴趣的元素。之后，你将在最后一个有趣的元素之后停止。</p>
<p>通常情况下，这需要访问你筛选掉的元素，而这就是问题所在 - 它需要从存储中读取元素。从存储中读取元素是处理数据的昂贵部分，我们尽量避免这样做。一种方法是指示 Map 从存储中的哪个位置开始和停止反序列化元素，以便它永远不会到达范围之外的元素。</p>
<p>还有一个需要注意的关键事项是，keys 和 range 函数返回的迭代器并不是元素的迭代器 - 它们是 <code>Result</code> 的迭代器。这是因为，尽管罕见，但可能存在这样一种情况：项应该存在，但在从存储中读取时出现错误 - 也许存储的值以我们未预料的方式进行了序列化，导致反序列化失败。这实际上是我过去在其中一个合约上工作时遇到的真实情况 - 我们更改了 Map 的值类型，然后忘记进行迁移，导致出现各种问题。</p>
<h2 id="将-map-视为集合"><a class="header" href="#将-map-视为集合">将 Map 视为集合</a></h2>
<p>所以我可以想象你现在可能会认为我很疯狂 - 为什么我在谈论一个 <code>Map</code>，而我们正在处理向量？显然这两者代表了两个不同的东西！还是说它们有所关联？</p>
<p>让我们重新考虑一下我们在 <code>ADMINS</code> 向量中保存的内容 - 我们有一个期望是唯一的对象列表，这是数学集合的定义。因此，现在让我重新提出我对Map的初步定义：</p>
<blockquote>
<p>首先，让我们定义一个Map - 在这个上下文中，它将是一个<em>键的集合</em>，每个键都有对应的值，就像 Rust 中的 HashMap 或许多其他语言中的字典一样。</p>
</blockquote>
<p>我故意在这里使用了&quot;集合&quot;这个词 - Map内嵌了集合。它是集合的一般化或逻辑的反转 - 集合是Map的特例。如果你想象一个将每个键映射到相同值的集合，那么值变得无关紧要，这样的Map在语义上就成为一个集合。</p>
<p>如何创建一个将所有键映射到相同值的Map？我们选择一个只有一个值的类型。通常在 Rust 中，它可能是一个 unit 类型 (<code>()</code>)，但在 CosmWasm 中，我们倾向于使用 CW 标准库中的 <a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.Empty.html"><code>Empty</code></a> 类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
<span class="boring">}</span></code></pre></pre>
<p>现在我们需要修复合约中对Map的使用。让我们从合约的实例化开始：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::msg::InstantiateMsg;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, admin, &amp;Empty {})?;
    }
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">}</span></code></pre></pre>
<p>并没有简化太多，但我们不再需要收集我们的地址。然后让我们转向离开逻辑：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{DepsMut, MessageInfo};

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, info.sender.clone());

    let resp = Response::new()
        .add_attribute(&quot;action&quot;, &quot;leave&quot;)
        .add_attribute(&quot;sender&quot;, info.sender.as_str());

    Ok(resp)
}
<span class="boring">}</span></code></pre></pre>
<p>在这里我们看到了一个区别 - 我们不需要加载整个向量。我们使用 <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.remove"><code>remove</code></a> 函数移除单个条目。</p>
<p>我之前没有强调的，并且相关的是，<code>Map</code> 将每个键都作为一个单独的项存储。这样，访问单个元素的成本比使用向量更低。</p>
<p>然而，这也有它的缺点 - 使用 Map 访问所有元素会消耗更多的 gas！一般情况下，我们会尽量避免这种情况 - 合约的线性复杂性可能导致非常昂贵的执行（从 gas 的角度）和潜在的漏洞 - 如果用户找到一种方法在这样的向量中创建许多虚拟元素，他可以使执行成本超过任何 gas 限制。</p>
<p>不幸的是，我们的合约中有这样的迭代 - 分发流程如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::error::ContractError;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    coins, BankMsg,DepsMut, MessageInfo, Order, Response
};

pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
    let denom = DONATION_DENOM.load(deps.storage)?;
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;

    let donation = cw_utils::must_pay(&amp;info, &amp;denom)?.u128();

    let donation_per_admin = donation / (admins.len() as u128);

    let messages = admins.into_iter().map(|admin| BankMsg::Send {
        to_address: admin.to_string(),
        amount: coins(donation_per_admin, &amp;denom),
    });

    let resp = Response::new()
        .add_messages(messages)
        .add_attribute(&quot;action&quot;, &quot;donate&quot;)
        .add_attribute(&quot;amount&quot;, donation.to_string())
        .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

    Ok(resp)
}
<span class="boring">}</span></code></pre></pre>
<p>如果我必须编写这样一个合约，并且这个 <code>donate</code> 是一个关键且经常调用的流程，我会建议在这里使用 <code>Item&lt;Vec&lt;Addr&gt;&gt;</code>。希望情况并非如此 - 分发不必是线性复杂度的！这可能听起来有点疯狂，因为我们必须遍历所有接收者来分发资金，但事实并非如此 - 有一种非常好的方法可以在常数时间内完成，我将在本书后面描述。目前，我们将保持不变，承认合约的缺陷，稍后再修复。</p>
<p>需要修复的最后一个函数是 <code>admins_list</code> 查询处理程序：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{Deps, Order, StdResult};

pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;
    let resp = AdminsListResp { admins };
    Ok(resp)
}
<span class="boring">}</span></code></pre></pre>
<p>在这里，我们也存在线性复杂性的问题，但问题要小得多。</p>
<p>首先，查询通常用于在本地节点上调用，没有 gas 成本 - 我们可以随意查询合约。</p>
<p>而且，即使我们对执行时间/成本有一些限制，也没有理由每次都查询所有项！我们将稍后修复这个函数，添加分页功能 - 限制查询调用者的执行时间/成本，使其能够请求从给定项开始的有限数量的项。通过阅读本章，你可能已经能够想象出实现它的方式，但当我介绍常见的 CosmWasm 实践时，我将展示我们通常是如何做到这一点的。</p>
<h2 id="参考键"><a class="header" href="#参考键">参考键</a></h2>
<p>在我们使用Map的过程中，还有一个微妙之处可以改进。</p>
<p>问题在于现在我们使用拥有的 Addr 键对Map进行索引。这迫使我们在想要重用键时对其进行克隆（特别是在离开实现中）。这不是一个巨大的成本，但我们可以避免它 - 我们可以将Map的键定义为引用：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;&amp;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}</span></code></pre></pre>
<p>最后，我们需要在两个地方修复Map的用法：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span>pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, &amp;admin, &amp;Empty {})?;
    }

    // ...

<span class="boring">   DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span>   Ok(Response::new())
}

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, &amp;info.sender);

    // ...

<span class="boring">   let resp = Response::new()
</span><span class="boring">       .add_attribute(&quot;action&quot;, &quot;leave&quot;)
</span><span class="boring">       .add_attribute(&quot;sender&quot;, info.sender.as_str());
</span><span class="boring">
</span>   Ok(resp)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-time"><a class="header" href="#working-with-time">Working with time</a></h1>
<p>The concept of time in the blockchain is tricky - as in
every distributed system, it is not easy to synchronize the
clocks of all the nodes.</p>
<p>However, there is the notion of a time that is even
monotonic - which means that it should never go &quot;backward&quot;
between executions. Also, what is important is - time is
always unique throughout the whole transaction - and even
the entire block, which is built of multiple transactions.</p>
<p>The time is encoded in the
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.Env.html"><code>Env</code></a>
type in its
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.BlockInfo.html"><code>block</code></a>
field, which looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlockInfo {
    pub height: u64,
    pub time: Timestamp,
    pub chain_id: String,
}
<span class="boring">}</span></code></pre></pre>
<p>You can see the <code>time</code> field, which is the timestamp of the
processed block. The <code>height</code> field is also worth
mentioning - it contains a sequence number of the processed
block. It is sometimes more useful than time, as it is
guaranteed that the <code>height</code> field is guaranteed to increase
between blocks, while two blocks may be executed with the
same <code>time</code> (even though it is rather not probable).</p>
<p>Also, many transactions might be executed in a single block.
That means that if we need a unique id for the execution of
a particular message, we should look for something more.
This thing is a
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.TransactionInfo.html"><code>transaction</code></a>
field of the <code>Env</code> type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TransactionInfo {
    pub index: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>index</code> here contains a unique index of the transaction
in the block. That means that to get the unique identifier
of a transaction through the whole block, we can use the
<code>(height, transaction_index)</code> pair.</p>
<h2 id="join-time"><a class="header" href="#join-time">Join time</a></h2>
<p>We want to use the time in our system to keep track of the
join time of admins. We don't yet add new members to the
group, but we can already set the join time of initial
admins. Let's start updating our state:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Timestamp};
use cw_storage_plus::Map;
<span class="boring">use cw_storage_plus::Item;
</span>
pub const ADMINS: Map&lt;&amp;Addr, Timestamp&gt; = Map::new(&quot;admins&quot;);
<span class="boring">pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>As you can see, our admins set became a proper map - we will
assign the join time to every admin.</p>
<p>Now we need to update how we initialize a map - we stored the Empty data previously, but it nevermore matches our value type. Let's check an updated instantiation function:</p>
<p>You might argue to create a separate structure for the value
of this map, so in the future, if we would need to add
something there, but in my opinion, it would be premature -
we can also change the entire value type in the future, as
it would be the same breaking change.</p>
<p>Now we need to update how we initialize a map - we stored
the <code>Empty</code> data previously, but it nevermore matches our
value type. Let's check an updated instantiation function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    DepsMut, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, &amp;admin, &amp;env.block.time)?;
    }
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of storing <code>&amp;Empty {}</code> as an admin value, we store
the join time, which we read from <code>&amp;env.block.time</code>. Also,
note that I removed the underscore from the name of the
<code>env</code> block - it was there only to ensure the Rust compiler
the variable is purposely unused and not some kind of a bug.</p>
<p>Finally, remember to remove any obsolete <code>Empty</code> imports
through the project - the compiler should help you point out
unused imports.</p>
<h2 id="query-and-tests"><a class="header" href="#query-and-tests">Query and tests</a></h2>
<p>The last thing to add regarding join time is the new query
asking for the join time of a particular admin. Everything
you need to do that was already discussed, I'll leave it for
you as an exercise. The query variant should look like:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[returns(JoinTimeResp)]
JoinTime { admin: String },
<span class="boring">}</span></code></pre></pre>
<p>And the example response type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
pub struct JoinTimeResp {
    pub joined: Timestamp,
}
<span class="boring">}</span></code></pre></pre>
<p>You may question that in response type, I suggest always returning a <code>joined</code>
value, but what to do when no such admin is added? Well, in such a case, I
would rely on the fact that <code>load</code> function returns a descriptive error of
missing value in storage - however, feel free to define your own error for such
a case or even make the <code>joined</code> field optional, and be returned if requested
admin exists.</p>
<p>Finally, there would be a good idea to make a test for new functionality - call
a new query right after instantiation to verify initial admins has proper join
time (possibly by extending the existing instantiation test).</p>
<p>One thing you might need help with in tests might be how to get the time of
execution. Using any OS-time would be doomed to fail - instead, you can call
the
<a href="https://docs.rs/cw-multi-test/0.16.4/cw_multi_test/struct.App.html#method.block_infohttps://docs.rs/cw-multi-test/0.16.4/cw_multi_test/struct.App.html#method.block_info"><code>block_info</code></a>
function to reach the
<a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.BlockInfo.html"><code>BlockInfo</code></a>
structure containing the block state at a particular moment in the app - calling
it just before instantiation would make you sure you are working with the same state
which would be simulated on the call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="法律信息"><a class="header" href="#法律信息">法律信息</a></h1>
<p>根据《德国电子商务法》第5条</p>
<h2 id="提供者"><a class="header" href="#提供者">提供者</a></h2>
<p>Confio GmbH<br />
柏林市波茨坦广场1号7楼<br />
10785 柏林</p>
<h2 id="总经理"><a class="header" href="#总经理">总经理</a></h2>
<p>Simon Warta</p>
<h2 id="联系方式"><a class="header" href="#联系方式">联系方式</a></h2>
<p><a href="mailto:hello@confio.gmbh">hello@confio.gmbh</a></p>
<h2 id="商业注册信息"><a class="header" href="#商业注册信息">商业注册信息</a></h2>
<p>商业注册号 HRB 221575，柏林查洛腾堡法院</p>
<h2 id="增值税号码"><a class="header" href="#增值税号码">增值税号码</a></h2>
<p>DE339802279</p>
<h2 id="内容负责人"><a class="header" href="#内容负责人">内容负责人</a></h2>
<p>Simon Warta<br />
Confio GmbH<br />
柏林市波茨坦广场1号7楼<br />
10785 柏林</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
